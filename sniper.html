<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Point & Click Sniper</title>
<style>
  :root{
    --bg:#0b0f14;
    --panel:#121822;
    --accent:#35c2ff;
    --ok:#34d399;
    --warn:#f59e0b;
    --err:#ef4444;
    --text:#e5edf5;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  .wrap{display:flex;flex-direction:column;height:100%;gap:.5rem; padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom) 12px;}
  header{
    display:grid;grid-template-columns:1fr auto;gap:.5rem;align-items:center;margin-top:.5rem;
  }
  .hud{
    display:grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    gap:.4rem;
    background:linear-gradient(180deg,#0d141e,#0a1018);
    border:1px solid #1c2634;border-radius:14px;padding:.5rem .6rem;
    box-shadow:0 6px 20px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.03);
    font-size:.95rem;
  }
  .hud .tag{opacity:.7;font-size:.75rem}
  .hud .val{font-weight:700;letter-spacing:.3px}
  .hud > div{display:flex;flex-direction:column;align-items:flex-start}
  .hud .best .val{color:var(--ok)}
  .hud .ammo .val{color:var(--warn)}
  .hud .time .val{color:var(--accent)}
  .btn{
    -webkit-tap-highlight-color: transparent;
    user-select:none; border:1px solid #203043;background:linear-gradient(180deg,#1a2533,#121a24);
    color:#e8f3ff;border-radius:12px;padding:.7rem 1rem;font-weight:700;
    box-shadow:0 6px 20px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.04);
  }
  .btn:active{transform:translateY(1px)}
  .canvasWrap{position:relative;flex:1;min-height:200px;border:1px solid #182232;border-radius:16px;overflow:hidden;background:
    radial-gradient(1200px 700px at 10% -10%, rgba(53,194,255,.08), transparent 60%),
    radial-gradient(1200px 700px at 110% 110%, rgba(53,194,255,.08), transparent 60%),
    #0b1119;}
  canvas{width:100%;height:100%;display:block;touch-action:none;cursor:none;}
  .footer{
    display:flex;gap:.6rem;align-items:center;justify-content:space-between;margin-bottom:.5rem;flex-wrap:wrap;
  }
  .roundLog{
    flex:1; min-width:240px;
    background:var(--panel); border:1px solid #1b2431; border-radius:12px; padding:.6rem .7rem; font-size:.9rem;
    max-height:30vh; overflow:auto;
  }
  .roundLog h3{margin:.1rem 0 .4rem 0; font-size:.9rem; opacity:.8}
  .roundLog .item{display:flex;justify-content:space-between;gap:.5rem;border-bottom:1px dashed #1f2a3a;padding:.2rem 0}
  .roundLog .item:last-child{border-bottom:none}
  .legend{font-size:.85rem; opacity:.8}
  .legend b{font-weight:700}
  @media (max-width:480px){
    .hud{grid-template-columns:repeat(2,minmax(0,1fr))}
    header{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="hud">
      <div class="score"><div class="tag">Punteggio</div><div class="val" id="scoreVal">0</div></div>
      <div class="ammo"><div class="tag">Colpi</div><div class="val" id="ammoVal">7</div></div>
      <div class="targets"><div class="tag">Bersagli</div><div class="val" id="targetsVal">5</div></div>
      <div class="best"><div class="tag">Best Score</div><div class="val" id="bestVal">0</div></div>
    </div>
    <button id="newRoundBtn" class="btn">Nuovo Round</button>
  </header>

  <div class="canvasWrap">
    <canvas id="game"></canvas>
  </div>

  <div class="footer">
    <div class="legend">üéØ <b>Hit</b>: 5px=100 ¬∑ 15px=50 ¬∑ 30px=20 ‚Äî ‚è±Ô∏è <span id="timeVal">00:00.000</span></div>
    <div class="roundLog">
      <h3>Storico Round</h3>
      <div id="log"></div>
    </div>
  </div>
</div>

<script>
(function(){
  'use strict';

  const RING_INNER = 5;
  const RING_MED   = 15;
  const RING_OUT   = 30;
  const RADIUS_TOTAL = RING_INNER + RING_MED + RING_OUT;
  const SCORES = { inner:100, med:50, out:20 };

  const TARGETS_PER_ROUND = 5;
  const BULLETS_PER_ROUND = 7;

  const LS_BEST_KEY = 'sniper_best_score_v1';

  const state = {
    running:false,
    score:0,
    bestScore: parseInt(localStorage.getItem(LS_BEST_KEY) || '0',10),
    bullets:BULLETS_PER_ROUND,
    targets:[],
    totalTargetsToClear: TARGETS_PER_ROUND,
    startTime: 0,
    endTime: 0,
    timeNow: 0,
    log: [],
    crosshair:{x:0,y:0}
  };

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.floor(rect.width  * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  new ResizeObserver(resizeCanvas).observe(canvas);

  const scoreEl   = document.getElementById('scoreVal');
  const ammoEl    = document.getElementById('ammoVal');
  const targetsEl = document.getElementById('targetsVal');
  const bestEl    = document.getElementById('bestVal');
  const timeEl    = document.getElementById('timeVal');
  const logEl     = document.getElementById('log');
  const newBtn    = document.getElementById('newRoundBtn');

  bestEl.textContent = state.bestScore;

  function randRange(min,max){ return Math.random()*(max-min)+min; }
  function clamp(v,min,max){ return v<min?min: (v>max?max:v); }
  function fmtTime(ms){
    const m = Math.floor(ms/60000);
    const s = Math.floor((ms%60000)/1000);
    const x = ms%1000;
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(x).padStart(3,'0')}`;
  }

  function spawnTargets(count){
    state.targets.length = 0;
    const W = canvas.clientWidth, H = canvas.clientHeight;
    const margin = 50; // at least 50px from border
    for(let i=0;i<count;i++){
      let placed = false;
      for(let attempt=0; attempt<100 && !placed; attempt++){
        const x = randRange(margin, W - margin);
        const y = randRange(margin, H - margin);
        let valid = true;
        for(const t of state.targets){
          const dx = x - t.x;
          const dy = y - t.y;
          if(Math.hypot(dx,dy) < 55){
            valid = false; break;
          }
        }
        if(valid){
          state.targets.push({x,y});
          placed = true;
        }
      }
    }
  }

  function startRound(){
    state.running = true;
    state.score = 0;
    state.bullets = BULLETS_PER_ROUND;
    state.totalTargetsToClear = TARGETS_PER_ROUND;
    state.startTime = performance.now();
    state.endTime = 0;
    spawnTargets(TARGETS_PER_ROUND);
    updateHUD();
  }

  function endRound(){
    if(!state.running) return;
    state.running = false;
    state.endTime = performance.now();
    const cleared = state.totalTargetsToClear===0;
    if(state.score > state.bestScore){
      state.bestScore = state.score;
      localStorage.setItem(LS_BEST_KEY, String(state.bestScore));
      bestEl.textContent = state.bestScore;
    }
    const timeMs = state.endTime - state.startTime;
    state.log.unshift({
      date: new Date().toLocaleString(),
      score: state.score,
      cleared,
      timeMs
    });
    renderLog();
    updateHUD();
  }

  function updateHUD(){
    scoreEl.textContent   = state.score;
    ammoEl.textContent    = state.bullets;
    targetsEl.textContent = state.totalTargetsToClear;
  }

  function renderLog(){
    logEl.innerHTML = '';
    state.log.slice(0,12).forEach(item=>{
      const div = document.createElement('div');
      div.className = 'item';
      const left = document.createElement('div');
      left.textContent = item.date;
      const right = document.createElement('div');
      right.innerHTML = `üèÅ ${fmtTime(item.timeMs)} &nbsp;‚Ä¢&nbsp; üéØ ${item.cleared?'<span style="color:#34d399">Cleared</span>':'<span style="color:#ef4444">DNF</span>'} &nbsp;‚Ä¢&nbsp; ‚≠ê ${item.score}`;
      div.appendChild(left); div.appendChild(right);
      logEl.appendChild(div);
    });
  }

  function screenToCanvas(e){
    const rect = canvas.getBoundingClientRect();
    let x,y;
    if(e.touches && e.touches.length){
      x = e.touches[0].clientX - rect.left;
      y = e.touches[0].clientY - rect.top;
    }else{
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    }
    return {x:clamp(x,0,rect.width), y:clamp(y,0,rect.height)};
  }

  function onShoot(e){
    e.preventDefault();
    if(!state.running) return;
    if(state.bullets<=0) return;

    state.bullets--;

    const p = screenToCanvas(e);
    let bestIdx = -1, bestScore = 0;

    for(let i=0;i<state.targets.length;i++){
      const t = state.targets[i];
      const dx = p.x - t.x;
      const dy = p.y - t.y;
      const d  = Math.hypot(dx,dy);
      if(d <= RADIUS_TOTAL){
        const score = d <= RING_INNER ? SCORES.inner
                    : d <= (RING_INNER+RING_MED) ? SCORES.med
                    : SCORES.out;
        if(score > bestScore){ bestScore = score; bestIdx = i; }
      }
    }
    if(bestIdx>=0){
      state.targets.splice(bestIdx,1);
      state.totalTargetsToClear--;
      state.score += bestScore;
    }

    updateHUD();

    if(state.totalTargetsToClear===0 || state.bullets===0){
      endRound();
    }
  }

  function drawTarget(t){
    const x=t.x, y=t.y;
    const g = ctx.createRadialGradient(x,y,2,x,y,RADIUS_TOTAL+8);
    g.addColorStop(0,'rgba(53,194,255,0.25)');
    g.addColorStop(1,'rgba(53,194,255,0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x,y,RADIUS_TOTAL+8,0,Math.PI*2);
    ctx.fill();

    ctx.lineWidth = 1.5;
    ctx.strokeStyle = 'rgba(200,230,255,0.35)';
    ctx.beginPath(); ctx.arc(x,y,RADIUS_TOTAL,0,Math.PI*2); ctx.stroke();

    ctx.strokeStyle = 'rgba(200,230,255,0.55)';
    ctx.beginPath(); ctx.arc(x,y,RING_INNER+RING_MED,0,Math.PI*2); ctx.stroke();

    ctx.strokeStyle = '#ffffff';
    ctx.beginPath(); ctx.arc(x,y,RING_INNER,0,Math.PI*2); ctx.stroke();

    ctx.fillStyle = 'rgba(53,194,255,0.07)';
    ctx.beginPath(); ctx.arc(x,y,RING_INNER+RING_MED,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(53,194,255,0.05)';
    ctx.beginPath(); ctx.arc(x,y,RADIUS_TOTAL,0,Math.PI*2); ctx.fill();

    ctx.fillStyle = '#35c2ff';
    ctx.beginPath(); ctx.arc(x,y,1.5,0,Math.PI*2); ctx.fill();
  }

  function drawCrosshair(){
    const x = state.crosshair.x;
    const y = state.crosshair.y;
    ctx.globalAlpha = .9;
    ctx.strokeStyle = '#35c2ff';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x-16,y); ctx.lineTo(x+16,y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x,y-16); ctx.lineTo(x,y+16); ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function render(ts){
    state.timeNow = ts || performance.now();
    const W = canvas.clientWidth, H = canvas.clientHeight;
    ctx.clearRect(0,0,W,H);

    const t = (state.running ? (state.timeNow - state.startTime)
                             : (state.endTime ? (state.endTime - state.startTime) : 0));
    timeEl.textContent = fmtTime(Math.max(0,t|0));

    for(const t of state.targets){ drawTarget(t); }

    drawCrosshair();

    requestAnimationFrame(render);
  }

  canvas.addEventListener('pointerdown', onShoot, {passive:false});
  canvas.addEventListener('touchstart', onShoot, {passive:false});

  canvas.addEventListener('mousemove', e=>{
    const p = screenToCanvas(e);
    state.crosshair.x = p.x;
    state.crosshair.y = p.y;
  });

  newBtn.addEventListener('click', startRound);

  resizeCanvas();
  state.crosshair.x = canvas.clientWidth/2;
  state.crosshair.y = canvas.clientHeight/2;
  render();
  startRound();

})();
</script>
</body>
</html>
