<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arena a Turni ‚Äì Simulazione Auto</title>
<style>
  :root{
    --bg:#0f1117; --panel:#151925; --accent:#5eead4; --muted:#93a4b6; --win:#86efac; --lose:#fca5a5; --warn:#fde047;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Arial,sans-serif;
    background:linear-gradient(180deg,#0b0e14,#0f1117);
    color:#e6edf3; line-height:1.45;
  }
  header{
    padding:12px 16px; display:flex; gap:12px; align-items:center; justify-content:space-between;
    position:sticky; top:0; background:rgba(15,17,23,.8); backdrop-filter: blur(8px); z-index:5; border-bottom:1px solid #1f2533;
  }
  h1{font-size:18px; margin:0; font-weight:700; letter-spacing:.2px}
  .controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  button{
    appearance:none; border:0; padding:12px 16px; border-radius:14px; font-weight:700; cursor:pointer;
    background:var(--accent); color:#081016; box-shadow:0 6px 20px rgba(94,234,212,.2);
    transition:transform .08s ease, filter .15s ease, opacity .2s ease;
  }
  button:active{ transform: translateY(1px) scale(.99); }
  .ghost{ background:#263041; color:#d6e2f0; box-shadow:none; }
  .field{
    display:grid; grid-template-columns:1fr; gap:10px; padding:10px; max-width:960px; margin:0 auto;
  }
  .card{
    background:var(--panel); border:1px solid #1f2533; border-radius:18px; overflow:hidden;
  }
  .row{ display:flex; gap:10px; flex-wrap:wrap; }
  canvas{ width:100%; height:52vh; display:block; background:#0b0e14; }
  @media (min-width:900px){
    .field{ grid-template-columns: 1.2fr .8fr; }
    canvas{ height:62vh; }
  }

  .section-title{ padding:10px 12px; font-size:12px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase; border-bottom:1px solid #1f2533; }
  .pad{ padding:12px; }
  .log{
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size:13px; white-space:pre-wrap; max-height:42vh; overflow:auto; padding:12px;
  }
  .log b{ color:#e6edf3; }
  .meta{ color:var(--muted); font-size:12px; }
  .inline{ display:inline-flex; align-items:center; gap:6px; }
  input[type="number"], select{
    background:#0f1522; border:1px solid #263041; color:#e6edf3; padding:10px 12px; border-radius:12px; width:100px; font-weight:600;
  }
  .stat{
    display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; margin:0 4px 4px 0; border:1px solid #263041; background:#0e1522;
  }
  footer{ padding:10px 16px; color:var(--muted); font-size:12px; text-align:center; }
  .badge{ padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #263041; background:#0e1522; }
  .summary { display:flex; gap:8px; flex-wrap:wrap; }
  .hpbar{
    height:6px; background:#1f2636; border-radius:6px; overflow:hidden; margin-top:6px;
  }
  .hpbar > i{
    display:block; height:100%; background:linear-gradient(90deg,#34d399,#22c55e); width:100%;
  }
</style>
</head>
<body>
  <header>
    <h1>üèüÔ∏è Arena a Turni ‚Äì Simulazione</h1>
    <div class="controls">
      <button id="startBtn">Start Battle</button>
      <button id="fastBtn" class="ghost" title="Velocizza animazioni">Velocit√† √ó1</button>
      <div class="inline">
        <label for="enemyCount" class="meta">Droni:</label>
        <input id="enemyCount" type="number" min="1" max="200" step="1" value="30">
      </div>
      <button id="clearLog" class="ghost">Svuota Log</button>
    </div>
  </header>

  <main class="field">
    <section class="card">
      <div class="section-title">Arena</div>
      <canvas id="arena" width="1200" height="700"></canvas>
      <div class="pad">
        <div class="summary" id="liveSummary"></div>
      </div>
    </section>

    <section class="card">
      <div class="section-title">Log</div>
      <div class="log" id="logBox" aria-live="polite"></div>
      <div class="pad">
        <div class="meta" id="lastResultMeta">Nessun risultato precedente.</div>
      </div>
    </section>
  </main>

  <footer>
    Salva automatico su <b>localStorage</b>. Canvas ottimizzato per mobile, tocca ‚ÄúStart Battle‚Äù per simulare.
  </footer>

<script>
(() => {
  // ====== Config di base (persistite) ======
  const LS_KEY_SETTINGS = "arena.settings.v1";
  const LS_KEY_LAST = "arena.lastResult.v1";

  const defaultSettings = {
    enemyCount: 30,
    speed: 1       // 1: normale, 2: rapido, 4: very fast
  };

  // Carica/salva impostazioni
  function loadSettings(){
    try{
      const raw = localStorage.getItem(LS_KEY_SETTINGS);
      if(!raw) return {...defaultSettings};
      const obj = JSON.parse(raw);
      return {...defaultSettings, ...obj};
    }catch(e){ return {...defaultSettings}; }
  }
  function saveSettings(s){ localStorage.setItem(LS_KEY_SETTINGS, JSON.stringify(s)); }

  function saveLastResult(resultObj){
    localStorage.setItem(LS_KEY_LAST, JSON.stringify({ savedAt: Date.now(), ...resultObj }));
    renderLastResultMeta();
  }
  function renderLastResultMeta(){
    const meta = document.getElementById("lastResultMeta");
    const raw = localStorage.getItem(LS_KEY_LAST);
    if(!raw){ meta.textContent = "Nessun risultato precedente."; return; }
    try{
      const data = JSON.parse(raw);
      const d = new Date(data.savedAt);
      meta.innerHTML = `Ultimo risultato salvato: <span class="badge">${d.toLocaleString()}</span><br>
                        Vincitore: <b>${data.winner}</b> ¬∑ Turni: <b>${data.turns}</b> ¬∑ Eroi vivi: <b>${data.heroesAlive}</b> ¬∑ Droni vivi: <b>${data.enemiesAlive}</b>`;
    }catch{
      meta.textContent = "Nessun risultato precedente.";
    }
  }

  // ====== Dati gioco ======
  const HERO_TEMPLATE = { maxHp:50, atk:10, def:0.10, attacksPerTurn:2, priority:"weakest" };
  const ENEMY_TEMPLATE = { maxHp:20, atk:5,  def:0.00, attacksPerTurn:1, priority:"random" };

  // ====== Stato UI ======
  const settings = loadSettings();
  const enemyCountInput = document.getElementById("enemyCount");
  enemyCountInput.value = settings.enemyCount;

  // ====== Canvas Setup ======
  const canvas = document.getElementById("arena");
  const ctx = canvas.getContext("2d");

  // Responsive resize to device pixel ratio for crispness
  function fitCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    drawScene(); // initial
  }
  window.addEventListener('resize', fitCanvas, {passive:true});
  fitCanvas();

  // ====== Utility ======
  const randInt = (min,max)=> Math.floor(Math.random()*(max-min+1))+min;
  const choice = arr => arr[arr.length-1 ? randInt(0,arr.length-1) : 0];

  function clamp(v, min, max){ return v<min?min: (v>max?max:v); }

  function damageAfterDefense(atk, targetDefPct){
    const dmg = Math.floor(atk * (1 - targetDefPct));
    return Math.max(1, dmg);
  }

  // ====== Entities ======
  function makeHeroes(){
    return Array.from({length:5}, (_,i)=>({
      id: `Eroe${i+1}`,
      team: "heroes",
      ...HERO_TEMPLATE,
      hp: HERO_TEMPLATE.maxHp,
      kills: 0,
      x: 0, y: 0
    }));
  }

  function makeEnemies(n){
    return Array.from({length:n}, (_,i)=>({
      id: `Drone${i+1}`,
      team: "enemies",
      ...ENEMY_TEMPLATE,
      hp: ENEMY_TEMPLATE.maxHp,
      kills: 0,
      x: 0, y: 0
    }));
  }

  // ====== Layout in Arena ======
  function layoutEntities(heroes, enemies){
    // heroes: colonna a sinistra in 5 slot verticali
    const pad = 24;
    const W = canvas.clientWidth, H = canvas.clientHeight;

    const heroX = pad + 40;
    const heroGap = (H - pad*2) / (heroes.length+1);
    heroes.forEach((h,idx)=>{
      h.x = heroX;
      h.y = pad + heroGap*(idx+1);
    });

    // enemies: griglia a destra
    const cols = Math.ceil(Math.sqrt(enemies.length));
    const rows = Math.ceil(enemies.length / cols);
    const gridW = Math.max(1, W - (heroX + 120) - pad);
    const cellW = gridW / cols;
    const cellH = (H - pad*2) / rows;
    const baseX = W - gridW - pad + cellW/2;
    const baseY = pad + cellH/2;

    enemies.forEach((e, i)=>{
      const r = Math.floor(i / cols);
      const c = i % cols;
      e.x = baseX + c*cellW;
      e.y = baseY + r*cellH;
    });
  }

  // ====== Render ======
  function drawScene(entities=[] , highlightLine=null){
    const W = canvas.clientWidth, H = canvas.clientHeight;
    // background
    ctx.clearRect(0,0,W,H);
    // grid
    ctx.globalAlpha = .35;
    ctx.strokeStyle = "#1f2533";
    for(let x=0; x<W; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0; y<H; y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha = 1;

    // mid divider
    ctx.strokeStyle = "#263041";
    ctx.beginPath(); ctx.moveTo(W*0.5, 0); ctx.lineTo(W*0.5,H); ctx.stroke();

    // draw units
    entities.forEach(u=>{
      const alive = u.hp>0;
      const r = u.team==="heroes" ? 18 : 12;
      const color = u.team==="heroes" ? "#5eead4" : "#93a4b6";
      const deadColor = "#3b455a";

      ctx.beginPath();
      ctx.fillStyle = alive?color:deadColor;
      ctx.arc(u.x, u.y, r, 0, Math.PI*2);
      ctx.fill();

      // name
      ctx.font = "12px ui-monospace, monospace";
      ctx.fillStyle = "#d6e2f0";
      ctx.textAlign = "center";
      ctx.fillText(u.id, u.x, u.y - (r+10));

      // hp bar
      const w = 46, h = 6;
      const pct = Math.max(0, u.hp) / u.maxHp;
      ctx.fillStyle = "#1f2636";
      ctx.fillRect(u.x - w/2, u.y + r + 6, w, h);
      ctx.fillStyle = pct>0.5 ? "#34d399" : (pct>0.25 ? "#fde047" : "#f87171");
      ctx.fillRect(u.x - w/2, u.y + r + 6, Math.floor(w*pct), h);
    });

    // attack line
    if(highlightLine){
      const {x1,y1,x2,y2} = highlightLine;
      ctx.strokeStyle = "#eab308"; // giallo
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.lineWidth = 1;
    }
  }

  // ====== Log ======
  const logBox = document.getElementById("logBox");
  function logLine(text){
    logBox.insertAdjacentHTML('beforeend', text + "\n");
    logBox.scrollTop = logBox.scrollHeight;
  }
  function clearLog(){ logBox.textContent=""; }

  // ====== Live Summary (HP + kills) ======
  const liveSummaryEl = document.getElementById("liveSummary");
  function renderLiveSummary(heroes, enemies){
    const heroHtml = heroes.map(h=>{
      const pct = Math.max(0, h.hp)/h.maxHp*100;
      return `<div class="card" style="padding:10px; border-radius:12px;">
        <div><b>${h.id}</b> <span class="stat">HP ${Math.max(0,Math.ceil(h.hp))}/${h.maxHp}</span> <span class="stat">Kills ${h.kills}</span></div>
        <div class="hpbar"><i style="width:${pct}%"></i></div>
      </div>`;
    }).join("");

    const enemyAlive = enemies.filter(e=>e.hp>0).length;
    const enemyHtml = `<div class="card" style="padding:10px; border-radius:12px;">
       <div><b>Nemici vivi</b>: <span class="badge">${enemyAlive}/${enemies.length}</span></div>
     </div>`;

    liveSummaryEl.innerHTML = heroHtml + enemyHtml;
  }

  // ====== Target selection ======
  function pickTarget(opponents, priority){
    const alive = opponents.filter(o=>o.hp>0);
    if(!alive.length) return null;
    if(priority==="random") return choice(alive);
    if(priority==="weakest"){
      // smallest HP, tie-break random
      let minHp = Math.min(...alive.map(o=>o.hp));
      const cands = alive.filter(o=>o.hp===minHp);
      return choice(cands);
    }
    // default
    return choice(alive);
  }

  // ====== Battle Loop ======
  let animSpeed = clamp(settings.speed, 1, 8); // 1,2,4,8
  const fastBtn = document.getElementById("fastBtn");
  function updateFastBtn(){
    fastBtn.textContent = `Velocit√† √ó${animSpeed}`;
  }
  updateFastBtn();

  async function sleep(ms){ return new Promise(r=>setTimeout(r, ms/animSpeed)); }

  async function animateAttack(attacker, target, entities){
    drawScene(entities, {x1:attacker.x, y1:attacker.y, x2:target.x, y2:target.y});
    await sleep(220);
    drawScene(entities, null);
  }

  async function runBattle(enemyCount){
    clearLog();
    const heroes = makeHeroes();
    const enemies = makeEnemies(enemyCount);
    layoutEntities(heroes, enemies);
    drawScene([...heroes, ...enemies]);
    renderLiveSummary(heroes, enemies);

    let turn = 1;
    let current = "heroes"; // heroes start
    logLine(`--- Inizio battaglia: Eroi vs ${enemyCount} Droni ---`);
    await sleep(400);

    // loop
    while( heroes.some(h=>h.hp>0) && enemies.some(e=>e.hp>0) ){
      logLine(`\nTurno ${turn} ¬∑ Muove: ${current==="heroes" ? "Eroi" : "Droni"}`);
      const attackers = (current==="heroes" ? heroes : enemies).filter(a=>a.hp>0);
      const defenders = (current==="heroes" ? enemies : heroes);

      // each attacker performs its attacksPerTurn
      for(const a of attackers){
        for(let k=0; k<a.attacksPerTurn; k++){
          const t = pickTarget(defenders, a.priority);
          if(!t) break; // no targets alive
          // compute damage
          const dmg = damageAfterDefense(a.atk, t.def);
          await animateAttack(a, t, [...heroes, ...enemies]);
          t.hp = Math.max(0, t.hp - dmg);

          // logging
          const nameA = a.id;
          const nameT = t.id;
          const remain = t.hp;
          logLine(`${nameA} attacca ${nameT}, fa ${dmg} danni, ${nameT} ha ${remain}hp rimanenti.`);

          // kill check
          if(remain<=0){
            logLine(`‚Üí ${nameT} √® stato sconfitto!`);
            a.kills = (a.kills||0)+1;
          }

          renderLiveSummary(heroes, enemies);
          drawScene([...heroes, ...enemies]);
          await sleep(160);
          if(!defenders.some(d=>d.hp>0)) break;
        }
        if(!defenders.some(d=>d.hp>0)) break;
      }

      // victory check mid-cycle
      const heroesAlive = heroes.some(h=>h.hp>0);
      const enemiesAlive = enemies.some(e=>e.hp>0);
      if(!heroesAlive || !enemiesAlive) break;

      // switch turn
      current = (current==="heroes" ? "enemies" : "heroes");
      if(current==="heroes") turn++;
      await sleep(250);
    }

    // outcome
    const heroesAliveN = heroes.filter(h=>h.hp>0).length;
    const enemiesAliveN = enemies.filter(e=>e.hp>0).length;
    const winner = enemiesAliveN===0 ? "Eroi" : "Droni";
    logLine(`\n=== Fine Battaglia ¬∑ Vincitore: ${winner} ===`);
    logLine(`Turni totali: ${turn}`);
    logLine(`\n‚Äî Riepilogo Eroi ‚Äî`);
    heroes.forEach(h=>{
      logLine(`${h.id}: HP ${h.hp}/${h.maxHp}, Nemici sconfitti: ${h.kills}`);
    });

    // save last result
    saveLastResult({
      winner, turns: turn, heroesAlive: heroesAliveN, enemiesAlive: enemiesAliveN,
      heroes: heroes.map(h=>({id:h.id, hp:h.hp, kills:h.kills})),
      enemiesTotal: enemies.length
    });

    // final draw to ensure state is visible
    drawScene([...heroes, ...enemies]);
    renderLiveSummary(heroes, enemies);
    return {winner, turn, heroes, enemies};
  }

  // ====== Wire UI ======
  document.getElementById("startBtn").addEventListener("click", async ()=>{
    // read and persist settings
    const n = clamp(parseInt(enemyCountInput.value||"30",10), 1, 200);
    settings.enemyCount = n;
    saveSettings(settings);
    await runBattle(n);
  });

  document.getElementById("clearLog").addEventListener("click", ()=> clearLog());

  fastBtn.addEventListener("click", ()=>{
    // cycle 1 -> 2 -> 4 -> 8 -> 1
    animSpeed = animSpeed===1 ? 2 : animSpeed===2 ? 4 : animSpeed===4 ? 8 : 1;
    updateFastBtn();
    settings.speed = animSpeed; saveSettings(settings);
  });

  // Initial meta render
  renderLastResultMeta();
})();
</script>
</body>
</html>
