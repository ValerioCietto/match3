<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arena a Turni ‚Äì Simulazione Auto (con Editor)</title>
<style>
  :root{
    --bg:#0f1117; --panel:#151925; --accent:#5eead4; --muted:#93a4b6; --win:#86efac; --lose:#fca5a5; --warn:#fde047;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Arial,sans-serif;
    background:linear-gradient(180deg,#0b0e14,#0f1117);
    color:#e6edf3; line-height:1.45;
  }
  header{
    padding:12px 16px; display:flex; gap:12px; align-items:center; justify-content:space-between;
    position:sticky; top:0; background:rgba(15,17,23,.8); backdrop-filter: blur(8px); z-index:5; border-bottom:1px solid #1f2533;
    flex-wrap:wrap;
  }
  h1{font-size:18px; margin:0; font-weight:700; letter-spacing:.2px}
  .controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  button{
    appearance:none; border:0; padding:12px 16px; border-radius:14px; font-weight:700; cursor:pointer;
    background:var(--accent); color:#081016; box-shadow:0 6px 20px rgba(94,234,212,.2);
    transition:transform .08s ease, filter .15s ease, opacity .2s ease;
  }
  button:active{ transform: translateY(1px) scale(.99); }
  .ghost{ background:#263041; color:#d6e2f0; box-shadow:none; }
  .field{
    display:grid; grid-template-columns:1fr; gap:10px; padding:10px; max-width:1200px; margin:0 auto;
  }
  .card{ background:var(--panel); border:1px solid #1f2533; border-radius:18px; overflow:hidden; }
  .section-title{ padding:10px 12px; font-size:12px; color:var(--muted); letter-spacing:.3px; text-transform:uppercase; border-bottom:1px solid #1f2533; }
  .pad{ padding:12px; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  canvas{ width:100%; height:52vh; display:block; background:#0b0e14; }
  @media (min-width:1000px){
    .field{ grid-template-columns: 1.35fr .65fr; }
    canvas{ height:62vh; }
  }
  .log{
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size:13px; white-space:pre-wrap; max-height:42vh; overflow:auto; padding:12px;
  }
  .meta{ color:var(--muted); font-size:12px; }
  .inline{ display:inline-flex; align-items:center; gap:6px; }
  input[type="number"], input[type="text"], select{
    background:#0f1522; border:1px solid #263041; color:#e6edf3; padding:10px 12px; border-radius:12px; min-width:76px; font-weight:600;
  }
  input[type="text"]{ min-width:110px;}
  .badge{ padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #263041; background:#0e1522; }
  .summary { display:flex; gap:8px; flex-wrap:wrap; }
  .hpbar{ height:6px; background:#1f2636; border-radius:6px; overflow:hidden; margin-top:6px; }
  .hpbar > i{ display:block; height:100%; background:linear-gradient(90deg,#34d399,#22c55e); width:100%; }
  .tabs{ display:flex; }
  .tab-btn{
    flex:1; text-align:center; padding:10px; cursor:pointer; border-bottom:2px solid transparent; font-weight:700;
  }
  .tab-btn.active{ border-bottom-color:var(--accent); background:#101626; }
  .hidden{ display:none; }
  .grid{ display:grid; gap:8px; }
  .grid-hero{
    grid-template-columns: 1fr repeat(4, 0.7fr);
  }
  @media (max-width:680px){
    .grid-hero{ grid-template-columns: 1fr 1fr; }
  }
  .table-like{ width:100%; border-collapse:separate; border-spacing:0 8px; }
  .table-like th{ text-align:left; font-size:12px; color:var(--muted); font-weight:700; padding:0 6px; }
  .row-card{
    display:grid; grid-template-columns: 1.2fr .8fr .8fr .9fr .9fr; gap:8px; background:#101626; padding:8px; border:1px solid #1f2533; border-radius:12px;
  }
  @media (max-width:820px){
    .row-card{ grid-template-columns: 1fr 1fr; }
  }
  .mini{ font-size:11px; color:var(--muted); }
</style>
</head>
<body>
  <header>
    <h1>üèüÔ∏è Arena a Turni ‚Äì Simulazione</h1>
    <div class="controls">
      <button id="startBtn">Start Battle</button>
      <button id="fastBtn" class="ghost" title="Velocizza animazioni">Velocit√† √ó1</button>
      <div class="inline">
        <label for="enemyCount" class="meta">Droni:</label>
        <input id="enemyCount" type="number" min="1" max="300" step="1" value="30">
      </div>
      <button id="clearLog" class="ghost">Svuota Log</button>
    </div>
  </header>

  <main class="field">
    <!-- LEFT: Arena -->
    <section class="card">
      <div class="section-title">Arena</div>
      <canvas id="arena" width="1200" height="700"></canvas>
      <div class="pad">
        <div class="summary" id="liveSummary"></div>
      </div>
    </section>

    <!-- RIGHT: Config + Log -->
    <section class="card">
      <div class="tabs">
        <div id="tabConfigBtn" class="tab-btn active">Config</div>
        <div id="tabLogBtn" class="tab-btn">Log</div>
      </div>

      <!-- CONFIG -->
      <div id="tabConfig" class="pad">
        <div class="section-title">Eroi (editor)</div>
        <div class="pad">
          <div id="heroesForm" class="grid"></div>
          <div class="mini" style="margin-top:6px;">I valori sono salvati automaticamente in <b>localStorage</b>.</div>
        </div>

        <div class="section-title">Nemici ‚Äì Template</div>
        <div class="pad">
          <div class="row" id="enemyTemplateForm">
            <label class="inline">HP <input type="number" id="et_hp" min="1" max="9999" step="1"></label>
            <label class="inline">ATK <input type="number" id="et_atk" min="1" max="9999" step="1"></label>
            <label class="inline">Priority
              <select id="et_priority">
                <option value="random">random</option>
                <option value="weakest">weakest</option>
              </select>
            </label>
          </div>
          <div class="mini" style="margin-top:6px;">La priority influisce sulla scelta del bersaglio per ogni attacco dei nemici.</div>
        </div>

        <div class="section-title">Impostazioni</div>
        <div class="pad row">
          <span class="badge">Droni iniziali: <span id="dronePreview">30</span></span>
          <span id="lastResultMeta" class="meta">Nessun risultato precedente.</span>
        </div>
      </div>

      <!-- LOG -->
      <div id="tabLog" class="hidden">
        <div class="section-title">Log</div>
        <div class="log" id="logBox" aria-live="polite"></div>
      </div>
    </section>
  </main>

  <footer>
    Salva automatico su <b>localStorage</b>. Canvas ottimizzato per mobile. Tocca ‚ÄúStart Battle‚Äù per simulare.
  </footer>

<script>
(() => {
  // ====== LocalStorage Keys ======
  const LS_KEY_SETTINGS = "arena.settings.v2";
  const LS_KEY_LAST = "arena.lastResult.v1";
  const LS_KEY_HEROES = "arena.heroes.v2";
  const LS_KEY_ENEMY_TEMPLATE = "arena.enemyTemplate.v2";

  // ====== Default Data ======
  const DEFAULT_HEROES = [
    { id:"Eroe1", name:"Eroe1", maxHp:50, atk:10, def:0.10, attacksPerTurn:2, priority:"weakest" },
    { id:"Eroe2", name:"Eroe2", maxHp:50, atk:10, def:0.10, attacksPerTurn:2, priority:"weakest" },
    { id:"Eroe3", name:"Eroe3", maxHp:50, atk:10, def:0.10, attacksPerTurn:2, priority:"weakest" },
    { id:"Eroe4", name:"Eroe4", maxHp:50, atk:10, def:0.10, attacksPerTurn:2, priority:"weakest" },
    { id:"Eroe5", name:"Eroe5", maxHp:50, atk:10, def:0.10, attacksPerTurn:2, priority:"weakest" },
  ];
  const DEFAULT_ENEMY_TEMPLATE = { maxHp:20, atk:5, def:0.00, attacksPerTurn:1, priority:"random" };
  const defaultSettings = { enemyCount:30, speed:1 };

  // ====== Load / Save ======
  const loadJSON = (k, fallback) => {
    try{ const r = localStorage.getItem(k); return r ? JSON.parse(r) : fallback; }
    catch{ return fallback; }
  };
  const saveJSON = (k, v) => localStorage.setItem(k, JSON.stringify(v));

  const settings = loadJSON(LS_KEY_SETTINGS, defaultSettings);
  const enemyTemplate = loadJSON(LS_KEY_ENEMY_TEMPLATE, DEFAULT_ENEMY_TEMPLATE);
  let heroesBase = loadJSON(LS_KEY_HEROES, DEFAULT_HEROES);

  // ====== Elements ======
  const enemyCountInput = document.getElementById("enemyCount");
  const dronePreview = document.getElementById("dronePreview");
  const lastResultMeta = document.getElementById("lastResultMeta");
  const heroesForm = document.getElementById("heroesForm");

  // Tabs
  const tabConfigBtn = document.getElementById("tabConfigBtn");
  const tabLogBtn = document.getElementById("tabLogBtn");
  const tabConfig = document.getElementById("tabConfig");
  const tabLog = document.getElementById("tabLog");
  tabConfigBtn.addEventListener("click", ()=>{ tabConfigBtn.classList.add("active"); tabLogBtn.classList.remove("active"); tabConfig.classList.remove("hidden"); tabLog.classList.add("hidden"); });
  tabLogBtn.addEventListener("click", ()=>{ tabLogBtn.classList.add("active"); tabConfigBtn.classList.remove("active"); tabLog.classList.remove("hidden"); tabConfig.classList.add("hidden"); });

  // ====== Canvas Setup ======
  const canvas = document.getElementById("arena");
  const ctx = canvas.getContext("2d");
  function fitCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    drawScene([]);
  }
  window.addEventListener('resize', fitCanvas, {passive:true});
  fitCanvas();

  // ====== Helpers ======
  const clamp = (v, min, max)=> v<min?min:(v>max?max:v);
  const randInt = (min,max)=> Math.floor(Math.random()*(max-min+1))+min;
  const choice = arr => arr[Math.floor(Math.random()*arr.length)];
  const damageAfterDefense = (atk, targetDefPct)=> Math.max(1, Math.floor(atk * (1 - targetDefPct)));

  function renderLastResultMeta(){
    const raw = localStorage.getItem(LS_KEY_LAST);
    if(!raw){ lastResultMeta.textContent = "Nessun risultato precedente."; return; }
    try{
      const data = JSON.parse(raw);
      const d = new Date(data.savedAt);
      lastResultMeta.innerHTML = `Ultimo risultato: <span class="badge">${d.toLocaleString()}</span> ¬∑ Vincitore: <b>${data.winner}</b> ¬∑ Turni: <b>${data.turns}</b> ¬∑ Eroi vivi: <b>${data.heroesAlive}</b> ¬∑ Droni vivi: <b>${data.enemiesAlive}</b>`;
    }catch{
      lastResultMeta.textContent = "Nessun risultato precedente.";
    }
  }
  renderLastResultMeta();

  // ====== Arena draw ======
  function drawScene(entities=[], highlightLine=null){
    const W = canvas.clientWidth, H = canvas.clientHeight;
    ctx.clearRect(0,0,W,H);
    // grid
    ctx.globalAlpha = .35;
    ctx.strokeStyle = "#1f2533";
    for(let x=0; x<W; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0; y<H; y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha = 1;

    ctx.strokeStyle = "#263041";
    ctx.beginPath(); ctx.moveTo(W*0.5, 0); ctx.lineTo(W*0.5,H); ctx.stroke();

    entities.forEach(u=>{
      const alive = u.hp>0;
      const r = u.team==="heroes" ? 18 : 12;
      const color = u.team==="heroes" ? "#5eead4" : "#93a4b6";
      const deadColor = "#3b455a";

      ctx.beginPath();
      ctx.fillStyle = alive?color:deadColor;
      ctx.arc(u.x, u.y, r, 0, Math.PI*2);
      ctx.fill();

      ctx.font = "12px ui-monospace, monospace";
      ctx.fillStyle = "#d6e2f0";
      ctx.textAlign = "center";
      ctx.fillText(u.id, u.x, u.y - (r+10));

      const w = 46, h = 6;
      const pct = Math.max(0, u.hp) / u.maxHp;
      ctx.fillStyle = "#1f2636";
      ctx.fillRect(u.x - w/2, u.y + r + 6, w, h);
      ctx.fillStyle = pct>0.5 ? "#34d399" : (pct>0.25 ? "#fde047" : "#f87171");
      ctx.fillRect(u.x - w/2, u.y + r + 6, Math.floor(w*pct), h);
    });

    if(highlightLine){
      const {x1,y1,x2,y2} = highlightLine;
      ctx.strokeStyle = "#eab308";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.lineWidth = 1;
    }
  }

  // ====== Layout ======
  function layoutEntities(heroes, enemies){
    const pad = 24;
    const W = canvas.clientWidth, H = canvas.clientHeight;

    const heroX = pad + 40;
    const heroGap = (H - pad*2) / (heroes.length+1);
    heroes.forEach((h,idx)=>{ h.x = heroX; h.y = pad + heroGap*(idx+1); });

    const cols = Math.ceil(Math.sqrt(enemies.length));
    const rows = Math.ceil(enemies.length / cols);
    const gridW = Math.max(1, W - (heroX + 120) - pad);
    const cellW = gridW / cols;
    const cellH = (H - pad*2) / rows;
    const baseX = W - gridW - pad + cellW/2;
    const baseY = pad + cellH/2;

    enemies.forEach((e, i)=>{
      const r = Math.floor(i / cols);
      const c = i % cols;
      e.x = baseX + c*cellW;
      e.y = baseY + r*cellH;
    });
  }

  // ====== Target selection ======
  function pickTarget(opponents, priority){
    const alive = opponents.filter(o=>o.hp>0);
    if(!alive.length) return null;
    if(priority==="random") return choice(alive);
    if(priority==="weakest"){
      let minHp = Math.min(...alive.map(o=>o.hp));
      const cands = alive.filter(o=>o.hp===minHp);
      return choice(cands);
    }
    return choice(alive);
  }

  // ====== Log ======
  const logBox = document.getElementById("logBox");
  function logLine(text){
    logBox.insertAdjacentHTML('beforeend', text + "\n");
    logBox.scrollTop = logBox.scrollHeight;
  }
  function clearLog(){ logBox.textContent=""; }

  // ====== Live Summary ======
  const liveSummaryEl = document.getElementById("liveSummary");
  function renderLiveSummary(heroes, enemies){
    const heroHtml = heroes.map(h=>{
      const pct = Math.max(0, h.hp)/h.maxHp*100;
      return `<div class="card" style="padding:10px; border-radius:12px;">
        <div><b>${h.id}</b> <span class="badge">HP ${Math.max(0,Math.ceil(h.hp))}/${h.maxHp}</span> <span class="badge">Kills ${h.kills}</span></div>
        <div class="hpbar"><i style="width:${pct}%"></i></div>
      </div>`;
    }).join("");

    const enemyAlive = enemies.filter(e=>e.hp>0).length;
    const enemyHtml = `<div class="card" style="padding:10px; border-radius:12px;">
       <div><b>Nemici vivi</b>: <span class="badge">${enemyAlive}/${enemies.length}</span></div>
     </div>`;

    liveSummaryEl.innerHTML = heroHtml + enemyHtml;
  }

  // ====== Forms: Heroes Editor ======
  function numberInput(opts){ // helper template
    const {id, min=0, max=9999, step=1, value=0} = opts;
    return `<input type="number" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}">`;
  }

  function renderHeroesForm(){
    heroesForm.innerHTML = `
      <div class="table-like">
        <div style="display:grid; grid-template-columns:1.2fr .8fr .8fr .9fr .9fr; gap:8px; padding:0 4px 6px;">
          <div class="meta">Nome</div>
          <div class="meta">HP</div>
          <div class="meta">ATK</div>
          <div class="meta">Attacchi/T</div>
          <div class="meta">Difesa %</div>
        </div>
        ${heroesBase.map((h,idx)=>`
          <div class="row-card">
            <input type="text" id="h_${idx}_name" value="${h.name ?? h.id}">
            ${numberInput({id:`h_${idx}_hp`, min:1, max:9999, step:1, value:h.maxHp})}
            ${numberInput({id:`h_${idx}_atk`, min:1, max:9999, step:1, value:h.atk})}
            ${numberInput({id:`h_${idx}_apt`, min:1, max:10, step:1, value:h.attacksPerTurn})}
            ${numberInput({id:`h_${idx}_def`, min:0, max:95, step:1, value:Math.round((h.def||0)*100)})}
          </div>
        `).join('')}
      </div>
    `;

    // wire inputs
    heroesBase.forEach((h,idx)=>{
      const nameEl = document.getElementById(`h_${idx}_name`);
      const hpEl   = document.getElementById(`h_${idx}_hp`);
      const atkEl  = document.getElementById(`h_${idx}_atk`);
      const aptEl  = document.getElementById(`h_${idx}_apt`);
      const defEl  = document.getElementById(`h_${idx}_def`);

      const apply = ()=>{
        h.name = (nameEl.value||`Eroe${idx+1}`).trim().slice(0,24);
        h.id = h.name;
        h.maxHp = clamp(parseInt(hpEl.value||h.maxHp,10), 1, 9999);
        h.atk = clamp(parseInt(atkEl.value||h.atk,10), 1, 9999);
        h.attacksPerTurn = clamp(parseInt(aptEl.value||h.attacksPerTurn,10), 1, 10);
        h.def = clamp(parseInt(defEl.value||Math.round((h.def||0)*100),10), 0, 95)/100;
        saveJSON(LS_KEY_HEROES, heroesBase);
      };

      [nameEl,hpEl,atkEl,aptEl,defEl].forEach(el=>{
        el.addEventListener('change', apply);
        el.addEventListener('input', (e)=>{ if(e.target===nameEl){ apply(); }});
      });
    });
  }

  // ====== Enemy Template Form ======
  const et_hp = document.getElementById("et_hp");
  const et_atk = document.getElementById("et_atk");
  const et_priority = document.getElementById("et_priority");

  function loadEnemyTemplateForm(){
    et_hp.value = enemyTemplate.maxHp;
    et_atk.value = enemyTemplate.atk;
    et_priority.value = enemyTemplate.priority;
  }
  function wireEnemyTemplateForm(){
    const apply = ()=>{
      enemyTemplate.maxHp = clamp(parseInt(et_hp.value||enemyTemplate.maxHp,10), 1, 9999);
      enemyTemplate.atk = clamp(parseInt(et_atk.value||enemyTemplate.atk,10), 1, 9999);
      enemyTemplate.priority = et_priority.value === "weakest" ? "weakest" : "random";
      saveJSON(LS_KEY_ENEMY_TEMPLATE, enemyTemplate);
    };
    [et_hp, et_atk, et_priority].forEach(el=>{
      el.addEventListener('change', apply);
      el.addEventListener('input', apply);
    });
  }

  renderHeroesForm();
  loadEnemyTemplateForm();
  wireEnemyTemplateForm();

  // ====== Settings wiring ======
  const fastBtn = document.getElementById("fastBtn");
  let animSpeed = clamp(settings.speed||1, 1, 8);
  function updateFastBtn(){ fastBtn.textContent = `Velocit√† √ó${animSpeed}`; }
  updateFastBtn();
  fastBtn.addEventListener("click", ()=>{
    animSpeed = animSpeed===1 ? 2 : animSpeed===2 ? 4 : animSpeed===4 ? 8 : 1;
    updateFastBtn();
    settings.speed = animSpeed;
    saveJSON(LS_KEY_SETTINGS, settings);
  });

  enemyCountInput.value = settings.enemyCount ?? 30;
  dronePreview.textContent = enemyCountInput.value;
  enemyCountInput.addEventListener('change', ()=>{
    settings.enemyCount = clamp(parseInt(enemyCountInput.value||"30",10), 1, 300);
    enemyCountInput.value = settings.enemyCount;
    dronePreview.textContent = settings.enemyCount;
    saveJSON(LS_KEY_SETTINGS, settings);
  });
  enemyCountInput.dispatchEvent(new Event('change'));

  // ====== Build entities from config ======
  function makeHeroesFromConfig(){
    return heroesBase.map(h=>({
      id: h.name || h.id,
      name: h.name || h.id,
      team: "heroes",
      maxHp: h.maxHp,
      atk: h.atk,
      def: h.def || 0,
      attacksPerTurn: h.attacksPerTurn,
      priority: "weakest",
      hp: h.maxHp,
      kills: 0,
      x:0,y:0
    }));
  }
  function makeEnemies(n){
    return Array.from({length:n}, (_,i)=>({
      id: `Drone${i+1}`,
      team: "enemies",
      maxHp: enemyTemplate.maxHp,
      atk: enemyTemplate.atk,
      def: enemyTemplate.def || 0,
      attacksPerTurn: enemyTemplate.attacksPerTurn || 1,
      priority: enemyTemplate.priority || "random",
      hp: enemyTemplate.maxHp,
      kills: 0,
      x:0,y:0
    }));
  }

  // ====== Battle Loop ======
  async function sleep(ms){ return new Promise(r=>setTimeout(r, ms/animSpeed)); }
  async function animateAttack(attacker, target, entities){
    drawScene(entities, {x1:attacker.x, y1:attacker.y, x2:target.x, y2:target.y});
    await sleep(220);
    drawScene(entities, null);
  }

  async function runBattle(enemyCount){
    clearLog();
    const heroes = makeHeroesFromConfig();
    const enemies = makeEnemies(enemyCount);
    layoutEntities(heroes, enemies);
    drawScene([...heroes, ...enemies]);
    renderLiveSummary(heroes, enemies);

    let turn = 1;
    let current = "heroes"; // eroi iniziano
    logLine(`--- Inizio battaglia: Eroi vs ${enemyCount} Droni ---`);
    await sleep(400);

    while( heroes.some(h=>h.hp>0) && enemies.some(e=>e.hp>0) ){
      logLine(`\nTurno ${turn} ¬∑ Muove: ${current==="heroes" ? "Eroi" : "Droni"}`);
      const attackers = (current==="heroes" ? heroes : enemies).filter(a=>a.hp>0);
      const defenders = (current==="heroes" ? enemies : heroes);

      for(const a of attackers){
        for(let k=0; k<a.attacksPerTurn; k++){
          const t = pickTarget(defenders, a.priority);
          if(!t) break;
          const dmg = damageAfterDefense(a.atk, t.def);
          await animateAttack(a, t, [...heroes, ...enemies]);
          t.hp = Math.max(0, t.hp - dmg);

          const nameA = a.id;
          const nameT = t.id;
          const remain = t.hp;
          logLine(`${nameA} attacca ${nameT}, fa ${dmg} danni, ${nameT} ha ${remain}hp rimanenti.`);
          if(remain<=0){
            logLine(`‚Üí ${nameT} √® stato sconfitto!`);
            a.kills = (a.kills||0)+1;
          }

          renderLiveSummary(heroes, enemies);
          drawScene([...heroes, ...enemies]);
          await sleep(160);
          if(!defenders.some(d=>d.hp>0)) break;
        }
        if(!defenders.some(d=>d.hp>0)) break;
      }

      const heroesAlive = heroes.some(h=>h.hp>0);
      const enemiesAlive = enemies.some(e=>e.hp>0);
      if(!heroesAlive || !enemiesAlive) break;

      current = (current==="heroes" ? "enemies" : "heroes");
      if(current==="heroes") turn++;
      await sleep(250);
    }

    const heroesAliveN = heroes.filter(h=>h.hp>0).length;
    const enemiesAliveN = enemies.filter(e=>e.hp>0).length;
    const winner = enemiesAliveN===0 ? "Eroi" : "Droni";
    logLine(`\n=== Fine Battaglia ¬∑ Vincitore: ${winner} ===`);
    logLine(`Turni totali: ${turn}`);
    logLine(`\n‚Äî Riepilogo Eroi ‚Äî`);
    heroes.forEach(h=>{
      logLine(`${h.id}: HP ${h.hp}/${h.maxHp}, Nemici sconfitti: ${h.kills}`);
    });

    saveJSON(LS_KEY_LAST, {
      savedAt: Date.now(),
      winner, turns: turn, heroesAlive: heroesAliveN, enemiesAlive: enemiesAliveN,
      heroes: heroes.map(h=>({id:h.id, hp:h.hp, kills:h.kills})),
      enemiesTotal: enemies.length
    });
    renderLastResultMeta();

    drawScene([...heroes, ...enemies]);
    renderLiveSummary(heroes, enemies);
    return {winner, turn, heroes, enemies};
  }

  // ====== Buttons ======
  document.getElementById("startBtn").addEventListener("click", async ()=>{
    const n = clamp(parseInt(enemyCountInput.value||"30",10), 1, 300);
    settings.enemyCount = n; saveJSON(LS_KEY_SETTINGS, settings);
    // passa al tab Log automaticamente per vedere l'azione
    tabLogBtn.click();
    await runBattle(n);
  });
  document.getElementById("clearLog").addEventListener("click", ()=> clearLog());
})();
</script>
</body>
</html>
