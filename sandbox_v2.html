<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Sand / Water / Rock Sandbox — 480×800 @60Hz</title>
<style>
  :root {
    color-scheme: dark;
    --bg: #0b0b0b;
    --fg: #eaeaea;
    --btn: #1c1c1c;
    --btn-hover: #2a2a2a;
    --accent: #ffd34d;
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial;
    overscroll-behavior: none;
  }
  .wrap {
    min-height: 100%;
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 8px;
    padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom);
  }
  header {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 10px 16px;
    padding-top: 8px;
  }
  h1 {
    font-size: 1rem;
    margin: 0;
    font-weight: 600;
    letter-spacing: .2px;
  }
  .controls {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
  }
  fieldset {
    border: 1px solid #2a2a2a;
    border-radius: 10px;
    padding: 6px 10px 10px;
    min-width: 230px;
  }
  legend { font-size: .9rem; opacity: .9; padding: 0 6px; }
  label {
    display: inline-flex; align-items: center; gap: 6px;
    margin-right: 10px; margin-top: 6px;
    cursor: pointer;
  }
  input[type="radio"] { accent-color: #ffd34d; }
  button {
    -webkit-tap-highlight-color: transparent;
    appearance: none;
    border: 1px solid #333;
    background: var(--btn);
    color: var(--fg);
    padding: 10px 14px;
    border-radius: 12px;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform .06s ease, background .15s ease;
    user-select: none;
  }
  button:hover { background: var(--btn-hover); }
  button:active { transform: translateY(1px) scale(0.99); }
  .canvas-shell {
    display: grid;
    place-items: center;
    overflow: auto;
  }
  canvas {
    width: 100%;
    max-width: 480px;
    height: auto;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: #151515;
    border-radius: 0;          /* corner radius 0px */
    box-shadow: 0 0 0 1px #222, 0 10px 30px rgba(0,0,0,.35);
    touch-action: none;
  }
  footer {
    font-size: 0.82rem;
    opacity: 0.8;
    text-align: center;
    padding: 6px 0 10px;
  }
  .dot {
    display:inline-block; width:10px; height:10px; border-radius:50%; margin-left:4px;
    vertical-align: middle; outline:1px solid #333;
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Sandbox 480×800 · 60Hz</h1>
      <div class="controls">
        <fieldset>
          <legend>Materiale</legend>
          <label><input type="radio" name="mat" value="sand" checked /> Sabbia <span class="dot" style="background:#e5dc28"></span></label>
          <label><input type="radio" name="mat" value="water" /> Acqua <span class="dot" style="background:#2d6df2"></span></label>
          <label><input type="radio" name="mat" value="rock" /> Roccia <span class="dot" style="background:#5a5a5a"></span></label>
        </fieldset>
        <button id="pauseBtn" aria-pressed="false" title="Pause/Resume simulation">⏯️ Pause</button>
      </div>
    </header>

    <div class="canvas-shell">
      <canvas id="canvas" width="480" height="800" aria-label="sand/water/rock simulation"></canvas>
    </div>

    <footer>
      Premi e tieni premuto: **1 pixel ogni 100 ms** del materiale selezionato. Stato autosalvato su localStorage.
    </footer>
  </div>

<script>
(() => {
  'use strict';

  /*** Config ***/
  const W = 480, H = 800;
  const DROP_INTERVAL_MS = 100;
  const FRAME_HZ = 60;
  const SAVE_INTERVAL_MS = 5000;

  // Materials enum
  const EMPTY=0, SAND=1, ROCK=2, WATER=3;

  // Colors
  // Sabbia: base gialla con jitter ±10 sul canale R
  const BASE_R = 245, R_JITTER = 10;
  const SAND_G = 220, SAND_B = 40, A = 255;
  // Roccia: grigio scuro
  const ROCK_R = 90, ROCK_G = 90, ROCK_B = 90;
  // Acqua: blu
  const WATER_R = 45, WATER_G = 110, WATER_B = 242;

  /*** State ***/
  let mat = new Uint8Array(W*H);       // materiale per cella
  let sandR = new Uint8Array(W*H);     // R per sabbia (persistente per granello)
  let rockHits = new Uint8Array(W*H);  // contatore impatti acqua dall’alto (0..10)

  // next buffers
  let nextMat = new Uint8Array(W*H);
  let nextSandR = new Uint8Array(W*H);
  let nextRockHits = new Uint8Array(W*H);

  const cvs = document.getElementById('canvas');
  const ctx = cvs.getContext('2d', { alpha:false });
  const img = ctx.createImageData(W,H);
  const px = img.data;

  // UI
  const pauseBtn = document.getElementById('pauseBtn');
  let paused = false;
  let currentMaterial = SAND;

  // Radio selector
  document.querySelectorAll('input[name="mat"]').forEach(r => {
    r.addEventListener('change', () => {
      const v = r.value;
      currentMaterial = (v === 'sand') ? SAND : (v === 'water' ? WATER : ROCK);
    });
  });

  /*** LocalStorage ***/
  const LS_KEY = 'sandbox_v2_sand_water_rock';
  function saveLS() {
    try {
      // Concatenate buffers: mat | sandR | rockHits
      const total = mat.length + sandR.length + rockHits.length;
      const buf = new Uint8Array(total);
      let off = 0;
      buf.set(mat, off); off += mat.length;
      buf.set(sandR, off); off += sandR.length;
      buf.set(rockHits, off);

      // Base64
      let binary = '';
      const chunk = 0x8000;
      for (let i=0;i<buf.length;i+=chunk) {
        binary += String.fromCharCode.apply(null, buf.subarray(i, i+chunk));
      }
      localStorage.setItem(LS_KEY, btoa(binary));
    } catch(e) {
      console.warn('Save failed', e);
    }
  }
  function loadLS() {
    try {
      const b64 = localStorage.getItem(LS_KEY);
      if (!b64) return;
      const binary = atob(b64);
      if (binary.length !== (mat.length + sandR.length + rockHits.length)) return;
      const buf = new Uint8Array(binary.length);
      for (let i=0;i<binary.length;i++) buf[i] = binary.charCodeAt(i);
      let off = 0;
      mat.set(buf.subarray(off, off+mat.length)); off += mat.length;
      sandR.set(buf.subarray(off, off+sandR.length)); off += sandR.length;
      rockHits.set(buf.subarray(off, off+rockHits.length));
    } catch(e) {
      console.warn('Load failed', e);
    }
  }
  loadLS();

  /*** Helpers ***/
  const idx = (x,y) => y*W + x;

  function jitterSandR() {
    let r = BASE_R + Math.floor(Math.random()*(2*R_JITTER+1) - R_JITTER);
    if (r<0) r=0; if (r>255) r=255;
    return r;
  }

  /*** Step ***/
  function step() {
    // clear next
    nextMat.fill(0);
    nextSandR.fill(0);
    nextRockHits.fill(0);

    // Pass-through immutable data (rockHits) by default; we’ll increment where needed
    // We’ll copy rockHits for rocks unless transformed.
    // Iterate bottom -> top
    for (let y=H-1; y>=0; y--) {
      for (let x=0; x<W; x++) {
        const i = idx(x,y);
        const m = mat[i];
        if (m === EMPTY) continue;

        if (m === SAND) {
          // Bottom border: cannot move below
          if (y === H-1) {
            nextMat[i] = SAND;
            nextSandR[i] = sandR[i] || BASE_R;
            continue;
          }

          const below = i + W;
          if (mat[below] === EMPTY) {
            nextMat[below] = SAND;
            nextSandR[below] = sandR[i] || BASE_R;
            continue;
          }

          // Below occupied
          if (x === 0 || x === W-1) {
            // Side border rule when bottom is occupied: stay
            nextMat[i] = SAND;
            nextSandR[i] = sandR[i] || BASE_R;
            continue;
          }

          // “sopra occupato” required to try slide
          const aboveOcc = (y>0) ? (mat[i - W] !== EMPTY) : false;
          if (aboveOcc) {
            const left = i - 1, right = i + 1;
            if (mat[left] === EMPTY && nextMat[left] === EMPTY) {
              nextMat[left] = SAND;
              nextSandR[left] = sandR[i] || BASE_R;
              continue;
            }
            if (mat[right] === EMPTY && nextMat[right] === EMPTY) {
              nextMat[right] = SAND;
              nextSandR[right] = sandR[i] || BASE_R;
              continue;
            }
          }

          // Stay
          nextMat[i] = SAND;
          nextSandR[i] = sandR[i] || BASE_R;

        } else if (m === ROCK) {
          // Rock is immobile by default
          let hits = rockHits[i] || 0;

          // If water is directly above in the current state, count as a hit
          if (y>0 && mat[i - W] === WATER) {
            hits = Math.min(255, hits + 1);
          }

          if (hits >= 10) {
            // Transform to sand
            nextMat[i] = SAND;
            nextSandR[i] = jitterSandR();
            // reset hits (no longer a rock)
            // (water above will be processed later; it can fall next frame)
          } else {
            nextMat[i] = ROCK;
            nextRockHits[i] = hits;
          }

        } else if (m === WATER) {
          // Water: gravity first
          if (y < H-1) {
            const below = i + W;
            if (mat[below] === EMPTY && nextMat[below] === EMPTY) {
              nextMat[below] = WATER;
              continue;
            }
          }

          // Then lateral (left first, then right)
          if (x > 0) {
            const left = i - 1;
            if (mat[left] === EMPTY && nextMat[left] === EMPTY) {
              nextMat[left] = WATER;
              continue;
            }
          }
          if (x < W-1) {
            const right = i + 1;
            if (mat[right] === EMPTY && nextMat[right] === EMPTY) {
              nextMat[right] = WATER;
              continue;
            }
          }

          // Stay
          nextMat[i] = WATER;
        }
      }
    }

    // Swap buffers
    [mat, nextMat] = [nextMat, mat];
    [sandR, nextSandR] = [nextSandR, sandR];
    [rockHits, nextRockHits] = [nextRockHits, rockHits];
  }

  /*** Draw ***/
  function draw() {
    let p = 0;
    for (let y=0; y<H; y++) {
      const yW = y*W;
      for (let x=0; x<W; x++) {
        const i = yW + x;
        const m = mat[i];
        if (m === EMPTY) {
          px[p] = 16; px[p+1] = 16; px[p+2] = 16; px[p+3] = 255;
        } else if (m === SAND) {
          px[p] = sandR[i] || BASE_R;
          px[p+1] = SAND_G;
          px[p+2] = SAND_B;
          px[p+3] = A;
        } else if (m === ROCK) {
          px[p] = ROCK_R; px[p+1] = ROCK_G; px[p+2] = ROCK_B; px[p+3] = A;
        } else if (m === WATER) {
          px[p] = WATER_R; px[p+1] = WATER_G; px[p+2] = WATER_B; px[p+3] = A;
        }
        p += 4;
      }
    }
    ctx.putImageData(img, 0, 0);
  }

  /*** Input ***/
  let isDown = false;
  let lastDrop = 0;

  function clientToCanvas(clientX, clientY) {
    const r = cvs.getBoundingClientRect();
    const sx = cvs.width / r.width;
    const sy = cvs.height / r.height;
    let x = Math.floor((clientX - r.left) * sx);
    let y = Math.floor((clientY - r.top) * sy);
    if (x<0) x=0; if (x>=W) x=W-1;
    if (y<0) y=0; if (y>=H) y=H-1;
    return {x,y};
  }

  function placeAt(x,y) {
    const i = idx(x,y);
    if (mat[i] !== EMPTY) return;
    if (currentMaterial === SAND) {
      mat[i] = SAND;
      sandR[i] = jitterSandR();
    } else if (currentMaterial === WATER) {
      mat[i] = WATER;
    } else {
      mat[i] = ROCK;
      rockHits[i] = 0;
    }
  }

  function maybeDrop(e) {
    const now = performance.now();
    if (now - lastDrop >= DROP_INTERVAL_MS) {
      lastDrop = now;
      const point = ('touches' in e && e.touches.length)
        ? clientToCanvas(e.touches[0].clientX, e.touches[0].clientY)
        : clientToCanvas(e.clientX, e.clientY);
      placeAt(point.x, point.y);
    }
  }

  cvs.addEventListener('mousedown', e => { isDown = true; maybeDrop(e); });
  window.addEventListener('mouseup', () => { isDown = false; });
  cvs.addEventListener('mousemove', e => { if (isDown) maybeDrop(e); });

  cvs.addEventListener('touchstart', e => { isDown = true; maybeDrop(e); e.preventDefault(); }, {passive:false});
  cvs.addEventListener('touchend',   e => { isDown = false; e.preventDefault(); }, {passive:false});
  cvs.addEventListener('touchmove',  e => { if (isDown) maybeDrop(e); e.preventDefault(); }, {passive:false});

  /*** Pause ***/
  function setPaused(v) {
    paused = v;
    pauseBtn.textContent = paused ? '▶️ Resume' : '⏯️ Pause';
    pauseBtn.setAttribute('aria-pressed', String(paused));
    if (paused) saveLS();
  }
  pauseBtn.addEventListener('click', () => setPaused(!paused));

  /*** Loop ***/
  let lastFrame = 0;
  const frameMs = 1000/FRAME_HZ;
  function loop(ts) {
    requestAnimationFrame(loop);
    if (paused) return;
    if (ts - lastFrame >= frameMs) {
      lastFrame = ts;
      step();
      draw();
    }
  }
  requestAnimationFrame(loop);

  /*** Autosave ***/
  let lastSave = performance.now();
  function saveTicker() {
    const now = performance.now();
    if (now - lastSave >= SAVE_INTERVAL_MS) {
      lastSave = now;
      saveLS();
    }
    setTimeout(saveTicker, 500);
  }
  saveTicker();
  window.addEventListener('beforeunload', saveLS);
})();
</script>
</body>
</html>
