<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Fantasy RTS ‚Äì Dragon Dogfight & Miner Spots</title>
<style>
  :root{
    --bg:#0d0f14; --panel:#171a22; --accent:#e0b168; --danger:#ff6b6b;
    --ok:#7ee081; --muted:#a9b0c0; --ink:#e6e9ef;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
  .wrap{display:flex;flex-direction:column;min-height:100%}
  header{padding:10px 12px;background:linear-gradient(180deg,#1b1f2a,#151823);display:flex;align-items:center;gap:12px;flex-wrap:wrap;position:sticky;top:0;z-index:5;border-bottom:1px solid rgba(255,255,255,0.06)}
  .stats{display:flex;gap:16px;align-items:center;flex:1;flex-wrap:wrap}
  .badge{padding:6px 10px;border-radius:999px;background:#11141c;border:1px solid rgba(255,255,255,0.06);font-weight:600}
  .hpbar{display:flex;align-items:center;gap:8px}
  .hpbar .bar{width:140px;max-width:28vw;height:10px;background:#2a2f3c;border-radius:6px;overflow:hidden}
  .hpbar .fill{height:100%;background:linear-gradient(90deg,var(--ok),#e5df72,var(--danger))}
  .controls{display:flex;gap:8px}
  button{background:var(--panel);color:var(--ink);border:1px solid rgba(255,255,255,0.08);padding:10px 12px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 2px 0 rgba(0,0,0,0.2);touch-action:manipulation}
  button:active{transform:translateY(1px)}
  button[disabled]{opacity:.5;cursor:not-allowed}
  #game{flex:1;display:flex;align-items:stretch;justify-content:center;padding:8px}
  canvas{width:100%;height:auto;max-height:calc(100vh - 220px);background:linear-gradient(180deg,#0f1320 60%, #242b3a);border-radius:16px;border:1px solid rgba(255,255,255,0.06)}
  .bar{position:sticky;bottom:0;z-index:6;background:linear-gradient(180deg,#121521,#0e111a 40%);border-top:1px solid rgba(255,255,255,0.06);padding:10px 8px}
  .units{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}
  .unit{display:flex;flex-direction:column;align-items:center;gap:6px;padding:8px;background:var(--panel);border:1px solid rgba(255,255,255,0.08);border-radius:14px}
  .unit button{width:100%;font-size:14px}
  .unit small{color:var(--muted)}
  .row{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-top:8px}
  .note{color:var(--muted);font-size:12px}
  .blink{animation:blink 1s infinite}
  @keyframes blink{50%{opacity:.4}}
  .toast{position:fixed;left:50%;bottom:110px;transform:translateX(-50%);background:#19202e;color:#fff;border:1px solid rgba(255,255,255,0.12);padding:10px 14px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.4);opacity:0;pointer-events:none;transition:opacity .2s, transform .2s}
  .toast.show{opacity:1;transform:translateX(-50%) translateY(-6px)}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="stats">
      <span class="badge" id="goldBadge">üí∞ Gold: 100</span>
      <div class="hpbar">
        <span>üè∞ You</span>
        <div class="bar"><div class="fill" id="hpYouFill" style="width:100%"></div></div>
        <span id="hpYouTxt">100/100</span>
      </div>
      <div class="hpbar">
        <span>üè∞ Enemy</span>
        <div class="bar"><div class="fill" id="hpEnemyFill" style="width:100%"></div></div>
        <span id="hpEnemyTxt">100/100</span>
      </div>
      <span class="badge" id="statusBadge">‚ñ∂Ô∏è Running</span>
    </div>
    <div class="controls">
      <button id="pauseBtn">‚è∏ Pause</button>
      <button id="resumeBtn" disabled>‚ñ∂Ô∏è Resume</button>
      <button id="resetBtn">üîÅ New Game</button>
    </div>
  </header>

  <div id="game">
    <canvas id="canvas" width="1200" height="520"></canvas>
  </div>

  <div class="bar">
    <div class="units">
      <div class="unit"><div>‚õèÔ∏è Miner</div><small>HP 10 ‚Ä¢ +10 GP/swing ‚Ä¢ 15 spots</small><button data-type="miner">Buy (25)</button></div>
      <div class="unit"><div>üó°Ô∏è Warrior</div><small>HP 40 ‚Ä¢ 10 dmg ‚Ä¢ 3%/s</small><button data-type="warrior">Buy (50)</button></div>
      <div class="unit"><div>üõ°Ô∏è Knight</div><small>HP 200 ‚Ä¢ 20 dmg ‚Ä¢ collision‚Üíattack‚Üíretreat 20%</small><button data-type="knight">Buy (150)</button></div>
      <div class="unit"><div>ü™µ Cart</div><small>HP 200 ‚Ä¢ High arc /2s</small><button data-type="cart">Buy (250)</button></div>
      <div class="unit"><div>üêâ Dragon</div><small>HP 1000 ‚Ä¢ Dogfight ‚â§50px</small><button data-type="dragon">Buy (1000)</button></div>
    </div>
    <div class="row">
      <div class="note">I draghi possono combattere i draghi. Le piazzole miner sono triangoli grigi.</div>
      <div class="note" id="autosaveNote">üíæ Auto-save attivo</div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  const SAVE_KEY = 'fantasy_rts_save_v2';
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const now = ()=>performance.now();

  const W = 1200, H = 520;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const ui = {
    goldBadge: document.getElementById('goldBadge'),
    hpYouFill: document.getElementById('hpYouFill'),
    hpEnemyFill: document.getElementById('hpEnemyFill'),
    hpYouTxt: document.getElementById('hpYouTxt'),
    hpEnemyTxt: document.getElementById('hpEnemyTxt'),
    statusBadge: document.getElementById('statusBadge'),
    pauseBtn: document.getElementById('pauseBtn'),
    resumeBtn: document.getElementById('resumeBtn'),
    resetBtn: document.getElementById('resetBtn'),
    toast: document.getElementById('toast')
  };

  const COST = { miner:25, warrior:50, knight:150, cart:250, dragon:1000 };
  const SPEED_PCT = { miner:2.5, warrior:3, knight:5, cart:1, dragon:6 };
  const HP = { miner:10, warrior:40, knight:200, cart:200, dragon:1000 };
  const DMG = { warrior:10, knight:20, cart:10, dragon:10 };
  const RATE = { warrior:1.0, knight:0.8, cart:0.5, dragon:1.0 };
  const MELEE_RANGE = 20;
  const DRAGON_DOGFIGHT_DIST = 50;
  const DRAGON_AOE_W = 50;

  const groundY = H*0.72;
  const skyY = H*0.30;
  const leftFortX = 40;
  const rightFortX = W-40;

  const state = {
    running:true,
    lastT: now(),
    playerGold:100,
    enemyGold:100,
    youHP:100,
    enemyHP:100,
    units:[],
    projectiles:[],
    ai:{
      maxMiners:5, warriorCount:0, warriorCap:10,
      knightCount:0, knightCap:10, cartCount:0, cartCap:20,
      lastMinerT:0, lastWarT:0, lastKniT:0, lastCartT:0, lastDragT:0
    },
    time:0,
    winner:null,
    minerSpotsLeft:[],   // [{x,occupied:false,by:null}]
    minerSpotsRight:[]
  };

  // Build miner spots (15 each side)
  function buildSpots(){
    state.minerSpotsLeft = [];
    state.minerSpotsRight = [];
    const baseL = 0.10 * canvas.width; // 10%
    const baseR = 0.90 * canvas.width; // 90%
    for(let i=0;i<15;i++){
      state.minerSpotsLeft.push({ x: baseL + i*2, occupied:false, by:null });
      state.minerSpotsRight.push({ x: baseR - i*2, occupied:false, by:null });
    }
  }
  buildSpots();

  let nextId=1;
  const pxPerSec = pct => (pct/100)*canvas.width;

  function toast(msg){
    const t = ui.toast;
    t.textContent = msg;
    t.classList.add('show');
    setTimeout(()=>t.classList.remove('show'), 1600);
  }

  function newUnit(side,type){
    const u={
      id: nextId++,
      side,type,
      hp: HP[type],
      x: side==='left'? leftFortX+20 : rightFortX-20,
      y: type==='dragon'? skyY : groundY,
      vx: (side==='left'? 1 : -1)*pxPerSec(SPEED_PCT[type]),
      facing: side==='left'? 1 : -1,
      timers:{ atk:0, mine:0, cart:0, dragon:0, knightBackCD:0 },
      state: type==='knight' ? 'advance' : (type==='miner' ? 'seek-spot' : 'move'),
      meta:{}
    };

    if(type==='miner'){
      // Assign nearest free spot for that side, else go back to fort
      const spots = side==='left' ? state.minerSpotsLeft : state.minerSpotsRight;
      let best=null, bestD=1e9, idx=-1;
      for(let i=0;i<spots.length;i++){
        if(!spots[i].occupied){
          const d = Math.abs(spots[i].x - u.x);
          if(d<bestD){bestD=d; best=spots[i]; idx=i;}
        }
      }
      if(best){
        best.occupied=true; best.by=u.id;
        u.meta.spotIndex = idx;
        u.meta.targetX = best.x;
        u.state='to-spot';
      }else{
        // no free spot, go back and refund on arrival
        u.state='returning';
        u.meta.refund=true;
      }
    }
    return u;
  }

  function spawn(side, type){
    if(side==='left'){
      if(state.playerGold < COST[type]) return false;
      state.playerGold -= COST[type];
    }else{
      if(state.enemyGold < COST[type]) return false;
      state.enemyGold -= COST[type];
    }
    state.units.push(newUnit(side,type));
    return true;
  }

  function tryBuyPlayer(type){
    if(state.winner) return;
    const ok = spawn('left', type);
    ui.goldBadge.classList.remove('blink');
    void ui.goldBadge.offsetWidth;
    if(!ok) ui.goldBadge.classList.add('blink');
    save();
  }

  // Save/Load
  function save(){
    const slim = {
      playerGold: state.playerGold, enemyGold: state.enemyGold,
      youHP: state.youHP, enemyHP: state.enemyHP, time: state.time, ai: state.ai,
      units: state.units.map(u=>({id:u.id,side:u.side,type:u.type,hp:u.hp,x:u.x,y:u.y,vx:u.vx,facing:u.facing,state:u.state,timers:u.timers,meta:u.meta})),
      projectiles: state.projectiles,
      minerSpotsLeft: state.minerSpotsLeft, minerSpotsRight: state.minerSpotsRight
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(slim));
  }
  function load(){
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return false;
      const s = JSON.parse(raw);
      state.playerGold = s.playerGold ?? 100;
      state.enemyGold = s.enemyGold ?? 100;
      state.youHP = s.youHP ?? 100;
      state.enemyHP = s.enemyHP ?? 100;
      state.time = s.time ?? 0;
      state.ai = s.ai ?? state.ai;
      state.units = (s.units??[]).map(u=>({...u}));
      state.projectiles = (s.projectiles??[]).map(p=>({...p}));
      state.minerSpotsLeft = s.minerSpotsLeft ?? state.minerSpotsLeft;
      state.minerSpotsRight = s.minerSpotsRight ?? state.minerSpotsRight;
      nextId = (state.units.reduce((m,u)=>Math.max(m,u.id),0)||0)+1;
      return true;
    }catch(e){ console.warn('Load failed', e); return false;}
  }
  load();

  function reset(){
    state.running=true; state.playerGold=100; state.enemyGold=100;
    state.youHP=100; state.enemyHP=100;
    state.units=[]; state.projectiles=[];
    state.time=0; state.winner=null;
    state.ai={maxMiners:5, warriorCount:0, warriorCap:10, knightCount:0, knightCap:10, cartCount:0, cartCap:20, lastMinerT:0, lastWarT:0, lastKniT:0, lastCartT:0, lastDragT:0};
    nextId=1;
    buildSpots();
    save();
  }

  // AI
  function aiUpdate(){
    const t = state.time, ai = state.ai;
    if(t - ai.lastMinerT >= 2){
      ai.lastMinerT = t;
      const miners = state.units.filter(u=>u.side==='right' && u.type==='miner').length;
      if(miners < ai.maxMiners) spawn('right','miner');
    }
    if(ai.warriorCount < ai.warriorCap && t - ai.lastWarT >= 5){
      ai.lastWarT = t; if(spawn('right','warrior')) ai.warriorCount++;
    }
    if(ai.knightCount < ai.knightCap && t - ai.lastKniT >= 10){
      ai.lastKniT = t; if(spawn('right','knight')) ai.knightCount++;
    }
    if(ai.cartCount < ai.cartCap && t - ai.lastCartT >= 50){
      ai.lastCartT = t; if(spawn('right','cart')) ai.cartCount++;
    }
    if(t - ai.lastDragT >= 120){
      ai.lastDragT = t; const ok = spawn('right','dragon');
      if(!ok){ ai.maxMiners += 1; spawn('right','miner'); }
    }
  }

  // Combat helpers
  function dealDamageToFort(side, amount){
    if(side==='left'){
      state.youHP = clamp(state.youHP - amount, 0, 100);
      if(state.youHP<=0 && !state.winner){ state.winner='Enemy'; state.running=false; ui.statusBadge.textContent='üíÄ You Lose'; }
    }else{
      state.enemyHP = clamp(state.enemyHP - amount, 0, 100);
      if(state.enemyHP<=0 && !state.winner){ state.winner='You'; state.running=false; ui.statusBadge.textContent='üèÜ You Win'; }
    }
  }

  function enemyAtRange(u){
    const foes = state.units.filter(v => v.side!==u.side && (u.type==='dragon')===(v.type==='dragon'));
    let nearest=null, bestD=1e9;
    for(const v of foes){
      const d = Math.abs(v.x - u.x);
      if(d < bestD) {bestD=d; nearest=v;}
    }
    if(nearest && bestD <= MELEE_RANGE) return nearest;
    return null;
  }

  // Projectiles (higher arc for carts)
  function spawnBoulder(u){
    const dir = u.side==='left'? 1 : -1;
    const p = {
      x: u.x + dir*10,
      y: u.y - 12,
      vx: dir * (canvas.width*0.20),   // slightly slower horizontal so arc looks higher
      vy: - (canvas.height*0.30),      // MUCH higher initial elevation
      g: (canvas.height*0.55),         // stronger gravity to fall back
      side: u.side,
      canHitDragon: true,
      ttl: 8
    };
    state.projectiles.push(p);
  }

  // Update
  function update(dt){
    if(!state.running) return;
    state.time += dt;

    aiUpdate();

    for(const u of state.units){
      // cooldowns
      if(u.timers.knightBackCD>0) u.timers.knightBackCD -= dt;

      if(u.type==='miner'){
        const spots = u.side==='left' ? state.minerSpotsLeft : state.minerSpotsRight;
        if(u.state==='to-spot' || u.state==='seek-spot'){
          // Move towards assigned target or try to assign if seeking
          if(u.state==='seek-spot'){
            let best=null, bestD=1e9, idx=-1;
            for(let i=0;i<spots.length;i++){
              if(!spots[i].occupied){
                const d = Math.abs(spots[i].x - u.x);
                if(d<bestD){bestD=d; best=spots[i]; idx=i;}
              }
            }
            if(best){
              best.occupied=true; best.by=u.id;
              u.meta.spotIndex = idx; u.meta.targetX = best.x; u.state='to-spot';
            }else{
              u.state='returning'; u.meta.refund=true;
            }
          }
          if(u.state==='to-spot'){
            const dir = Math.sign(u.meta.targetX - u.x) || (u.side==='left'?1:-1);
            u.x += dir * pxPerSec(SPEED_PCT.miner) * dt;
            if(Math.abs(u.x - u.meta.targetX) < 1.5){
              u.x = u.meta.targetX; u.state='mine'; u.timers.mine=0;
            }
          }
        }else if(u.state==='mine'){
          u.timers.mine += dt;
          if(u.timers.mine >= 1.5){
            u.timers.mine = 0;
            if(u.side==='left') state.playerGold += 10; else state.enemyGold += 10;
          }
        }else if(u.state==='returning'){
          const dir = (u.side==='left' ? -1 : 1);
          u.x += dir * pxPerSec(SPEED_PCT.miner) * dt;
          // arrived to fort?
          if( (u.side==='left' && u.x <= leftFortX+8) || (u.side==='right' && u.x >= rightFortX-8) ){
            // refund and remove
            if(u.meta.refund){
              if(u.side==='left'){ state.playerGold += COST.miner; toast('miner returned because no free spots!'); }
              else { state.enemyGold += COST.miner; }
            }
            // free any spot reserved (shouldn't have)
            if(u.meta.spotIndex!=null){
              const arr = u.side==='left'? state.minerSpotsLeft : state.minerSpotsRight;
              const s = arr[u.meta.spotIndex]; if(s && s.by===u.id){ s.occupied=false; s.by=null; }
            }
            u.hp = -1; // mark for removal
          }
        }
      }
      else if(u.type==='cart'){
        u.x += u.vx * dt;
        u.timers.cart += dt;
        if(u.timers.cart >= 2){ u.timers.cart = 0; spawnBoulder(u); }
      }
      else if(u.type==='dragon'){
        // Dogfight check
        const foeDragons = state.units.filter(v=>v.type==='dragon' && v.side!==u.side);
        let nearest=null, best=1e9;
        for(const v of foeDragons){
          const d=Math.abs(v.x-u.x);
          if(d<best){best=d;nearest=v;}
        }
        if(nearest && best <= DRAGON_DOGFIGHT_DIST){
          // dogfight: stop and exchange hits
          u.state='dogfight';
          u.timers.dragon += dt;
          if(u.timers.dragon >= (1/RATE.dragon)){
            u.timers.dragon = 0;
            // damage the nearest enemy dragon
            nearest.hp -= DMG.dragon;
          }
        }else{
          // normal flight & flame to ground / fortress
          u.state='move';
          u.x += (u.vx || pxPerSec(SPEED_PCT.dragon)*(u.side==='left'?1:-1)) * dt;
          // flame tick
          u.timers.dragon += dt;
          if(u.timers.dragon >= (1/RATE.dragon)){
            u.timers.dragon = 0;
            const minX = u.x - DRAGON_AOE_W/2, maxX = u.x + DRAGON_AOE_W/2;
            for(const v of state.units){
              if(v.side!==u.side && v.type!=='dragon'){
                if(v.x>=minX && v.x<=maxX) v.hp -= DMG.dragon;
              }
            }
            if(u.side==='left'){
              if(Math.abs(u.x - rightFortX) < DRAGON_AOE_W) dealDamageToFort('right', DMG.dragon);
            }else{
              if(Math.abs(u.x - leftFortX) < DRAGON_AOE_W) dealDamageToFort('left', DMG.dragon);
            }
          }
        }
      }
      else if(u.type==='warrior'){
        // move or melee with cadence
        const foe = enemyAtRange(u);
        if(foe){
          u.timers.atk += dt;
          if(u.timers.atk >= 1/RATE.warrior){ u.timers.atk=0; foe.hp -= DMG.warrior; }
        }else{
          u.x += u.vx * dt;
        }
        // Fortress punch if in range
        if(u.side==='left' && u.x >= rightFortX - MELEE_RANGE){
          u.timers.atk += dt; if(u.timers.atk >= 1/RATE.warrior){ u.timers.atk=0; dealDamageToFort('right', DMG.warrior); }
        }
        if(u.side==='right' && u.x <= leftFortX + MELEE_RANGE){
          u.timers.atk += dt; if(u.timers.atk >= 1/RATE.warrior){ u.timers.atk=0; dealDamageToFort('left', DMG.warrior); }
        }
      }
      else if(u.type==='knight'){
        // States: advance -> (on collision) instant-hit -> retreating -> advance again
        if(u.state==='advance'){
          // Check collision with unit or fortress front
          // Enemy unit collision
          const foes = state.units.filter(v=>v.side!==u.side && (v.type!=='dragon')); // ground only
          let nearest=null, bestD=1e9;
          for(const v of foes){ const d=Math.abs(v.x-u.x); if(d<bestD){bestD=d;nearest=v;} }
          const collideUnit = nearest && bestD <= MELEE_RANGE;
          const collideFort = (u.side==='left' && u.x >= rightFortX - MELEE_RANGE) ||
                               (u.side==='right' && u.x <= leftFortX + MELEE_RANGE);
          if(collideUnit || collideFort){
            // INSTANT STRIKE
            if(collideUnit){ nearest.hp -= DMG.knight; }
            else { dealDamageToFort(u.side==='left'?'right':'left', DMG.knight); }
            // start retreat phase (travel back 20% at normal speed)
            u.state='retreat';
            u.timers.knightBackCD = 0.1; // tiny guard
            const back = (canvas.width*0.20) * (u.side==='left' ? -1 : 1);
            u.meta.retreatTargetX = clamp(u.x + back, leftFortX+10, rightFortX-10);
          }else{
            u.x += u.vx * dt;
          }
        }else if(u.state==='retreat'){
          const dir = Math.sign(u.meta.retreatTargetX - u.x);
          const speed = pxPerSec(SPEED_PCT.knight) * dir;
          u.x += speed * dt;
          if(Math.abs(u.x - u.meta.retreatTargetX) < 2){
            u.state='advance';
          }
        }
      }
    }

    // Projectiles update
    for(const p of state.projectiles){
      p.ttl -= dt;
      p.x += p.vx * dt;
      p.vy += p.g * dt;
      p.y += p.vy * dt;
      // collisions
      for(const u of state.units){
        if(u.side===p.side) continue;
        if(u.type==='dragon' && !p.canHitDragon) continue;
        const dx=u.x-p.x, dy=u.y-p.y, d2=dx*dx+dy*dy;
        if(d2 < 18*18){
          u.hp -= DMG.cart; p.ttl=0; break;
        }
      }
      // forts (ground threshold)
      if(p.side==='left' && Math.abs(p.x - rightFortX) < 14 && p.y>groundY-30){
        dealDamageToFort('right', DMG.cart); p.ttl=0;
      }
      if(p.side==='right' && Math.abs(p.x - leftFortX) < 14 && p.y>groundY-30){
        dealDamageToFort('left', DMG.cart); p.ttl=0;
      }
    }

    // Miner spot freeing on death
    for(const u of state.units){
      if(u.hp<=0 && u.type==='miner' && u.meta.spotIndex!=null){
        const arr = u.side==='left'? state.minerSpotsLeft : state.minerSpotsRight;
        const s = arr[u.meta.spotIndex]; if(s && s.by===u.id){ s.occupied=false; s.by=null; }
      }
    }

    // Sweep
    state.units = state.units.filter(u=>u.hp>0 && u.x>leftFortX-80 && u.x<rightFortX+80);
    state.projectiles = state.projectiles.filter(p=>p.ttl>0 && p.x>-60 && p.x<canvas.width+60 && p.y>-120 && p.y<canvas.height+120);

    // UI
    ui.goldBadge.textContent = `üí∞ Gold: ${state.playerGold}`;
    ui.hpYouFill.style.width = (state.youHP)+'%';
    ui.hpEnemyFill.style.width = (state.enemyHP)+'%';
    ui.hpYouTxt.textContent = `${state.youHP}/100`;
    ui.hpEnemyTxt.textContent = `${state.enemyHP}/100`;

    if(Math.floor(state.time)%5 < dt){ save(); }
  }

  // Rendering
  function drawFort(x, side){
    ctx.save();
    ctx.translate(x, groundY);
    ctx.fillStyle = '#30384a';
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.fillRect(side==='left'?-30:-40, -80, 70, 80);
    ctx.strokeRect(side==='left'?-30:-40, -80, 70, 80);
    for(let i=0;i<5;i++){
      const bx = (side==='left'?-30:-40) + i*14;
      ctx.fillRect(bx, -90, 10, 10);
    }
    ctx.restore();
  }

  function drawMinerSpots(){
    ctx.save();
    ctx.strokeStyle='rgba(200,200,210,0.9)';
    ctx.fillStyle='rgba(180,180,190,0.9)';
    // small grey triangles (pointing up) just above ground line
    const drawTri = (x)=>{
      ctx.beginPath();
      ctx.moveTo(x, groundY-18);
      ctx.lineTo(x-6, groundY-6);
      ctx.lineTo(x+6, groundY-6);
      ctx.closePath();
      ctx.fill();
    };
    state.minerSpotsLeft.forEach(s=>drawTri(s.x));
    state.minerSpotsRight.forEach(s=>drawTri(s.x));
    ctx.restore();
  }

  function drawUnit(u){
    ctx.save();
    const colBase = (u.side==='left')? '#7ee081' : '#ff8aa6';
    ctx.lineWidth=2;

    if(u.type==='miner'){
      ctx.fillStyle=colBase;
      ctx.beginPath();
      ctx.moveTo(u.x, groundY-12);
      ctx.lineTo(u.x-10, groundY+10);
      ctx.lineTo(u.x+10, groundY+10);
      ctx.closePath(); ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.stroke();
      if(u.state==='mine'){
        const swing = Math.sin(state.time*8)*6;
        ctx.strokeStyle = '#e0b168';
        ctx.beginPath();
        ctx.moveTo(u.x+6, groundY-6);
        ctx.lineTo(u.x+6 + swing, groundY-18);
        ctx.stroke();
      }
    }
    else if(u.type==='warrior'){
      ctx.fillStyle=colBase;
      ctx.fillRect(u.x-10, groundY-20, 20, 20);
      ctx.beginPath(); ctx.arc(u.x, groundY-26, 6, 0, Math.PI*2); ctx.fill();
      const swing = Math.sin((state.time*6)+u.id)*8;
      ctx.strokeStyle='#e6e9ef';
      ctx.beginPath();
      ctx.moveTo(u.x+12*(u.facing), groundY-16);
      ctx.lineTo(u.x+12*(u.facing)+swing, groundY-28);
      ctx.stroke();
    }
    else if(u.type==='knight'){
      ctx.fillStyle=colBase;
      ctx.fillRect(u.x-14, groundY-24, 28, 24);
      ctx.beginPath();
      if(u.facing>0){ ctx.moveTo(u.x+14, groundY-24); ctx.lineTo(u.x+30, groundY-12); ctx.lineTo(u.x+14, groundY); }
      else{ ctx.moveTo(u.x-14, groundY-24); ctx.lineTo(u.x-30, groundY-12); ctx.lineTo(u.x-14, groundY); }
      ctx.closePath(); ctx.fill();
      // State hint
      if(u.state==='retreat'){
        ctx.fillStyle='rgba(255,255,255,0.25)';
        ctx.fillRect(u.x-16, groundY-36, 32, 6);
      }
    }
    else if(u.type==='cart'){
      ctx.fillStyle=colBase;
      ctx.fillRect(u.x-16, groundY-16, 32, 16);
      ctx.beginPath(); ctx.arc(u.x-10, groundY, 6, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(u.x+10, groundY, 6, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='#caa57a';
      ctx.beginPath();
      ctx.moveTo(u.x, groundY-16);
      ctx.lineTo(u.x + u.facing*18, groundY-28);
      ctx.stroke();
    }
    else if(u.type==='dragon'){
      ctx.fillStyle=(u.side==='left')? '#67d3ff' : '#ffcf66';
      ctx.beginPath(); ctx.ellipse(u.x, skyY-10, 24, 12, 0, 0, Math.PI*2); ctx.fill();
      const flap = Math.sin(state.time*6 + u.id)*10;
      ctx.beginPath(); ctx.moveTo(u.x-24, skyY-10); ctx.lineTo(u.x-40, skyY-20-flap); ctx.lineTo(u.x-12, skyY-14); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(u.x+24, skyY-10); ctx.lineTo(u.x+40, skyY-20-flap); ctx.lineTo(u.x+12, skyY-14); ctx.closePath(); ctx.fill();
      if(u.state==='move'){
        ctx.fillStyle='rgba(255,110,64,0.35)';
        ctx.beginPath(); ctx.moveTo(u.x-DRAGON_AOE_W/2, skyY); ctx.lineTo(u.x+DRAGON_AOE_W/2, skyY); ctx.lineTo(u.x, groundY); ctx.closePath(); ctx.fill();
      }else if(u.state==='dogfight'){
        // simple aura to show dogfight lock
        ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.setLineDash([4,4]);
        ctx.beginPath(); ctx.arc(u.x, skyY-10, 32, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
      }
    }

    // HP bar
    const maxHP = HP[u.type];
    const pct = clamp(u.hp/maxHP,0,1);
    const uy = (u.type==='dragon')? skyY : groundY;
    ctx.fillStyle='#2a2f3c';
    ctx.fillRect(u.x-16, uy-34, 32, 4);
    ctx.fillStyle = pct>0.5? '#7ee081' : pct>0.25? '#e5df72' : '#ff6b6b';
    ctx.fillRect(u.x-16, uy-34, 32*pct, 4);

    ctx.restore();
  }

  function drawProjectile(p){
    ctx.save();
    ctx.fillStyle='#caa57a';
    ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // ground line
    ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(0, groundY+1); ctx.lineTo(canvas.width, groundY+1); ctx.stroke();
    // forts
    drawFort(leftFortX, 'left'); drawFort(rightFortX, 'right');
    // miner spots
    drawMinerSpots();
    // units
    for(const u of state.units) drawUnit(u);
    // projectiles
    for(const p of state.projectiles) drawProjectile(p);

    if(state.winner){
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#fff'; ctx.font='bold 36px system-ui, sans-serif'; ctx.textAlign='center';
      ctx.fillText(state.winner==='You'?'YOU WIN!':'YOU LOSE!', canvas.width/2, canvas.height/2);
      ctx.restore();
    }
  }

  // Main loop
  function loop(){
    const t = now(); let dt = (t - state.lastT)/1000; state.lastT = t; dt = Math.min(dt, 0.05);
    if(state.running) update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // UI
  document.querySelectorAll('.unit button').forEach(btn=>{
    btn.addEventListener('click', ()=>tryBuyPlayer(btn.dataset.type));
  });
  ui.pauseBtn.addEventListener('click', ()=>{state.running=false; ui.statusBadge.textContent='‚è∏ Paused'; ui.pauseBtn.disabled=true; ui.resumeBtn.disabled=false; save();});
  ui.resumeBtn.addEventListener('click', ()=>{state.running=true; ui.statusBadge.textContent='‚ñ∂Ô∏è Running'; ui.pauseBtn.disabled=false; ui.resumeBtn.disabled=true;});
  ui.resetBtn.addEventListener('click', reset);

  // Seed some AI miners to get it going
  (function seedAI(){
    for(let i=0;i<Math.min(4, state.ai.maxMiners); i++){ if(state.enemyGold>=COST.miner) spawn('right','miner'); }
  })();
})();
</script>
</body>
</html>
