<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Vertical Scroll Shooter</title>
<style>
  :root{
    --controls-h: 64px; /* >= 50px */
    --bg: #0b0e13;
    --ink: #e6e6e6;
    --accent: #35c3ff;
  }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans"; }
  body { display: flex; flex-direction: column; overflow: hidden; }

  .topbar{
    position: fixed; inset: env(safe-area-inset-top) 0 auto 0;
    height: 44px; display: flex; align-items: center; justify-content: flex-end;
    padding: 0 12px calc(env(safe-area-inset-top));
    pointer-events: none; z-index: 5;
  }
  .topbar a.upgrades {
    pointer-events: auto;
    text-decoration: none; background: rgba(255,255,255,0.08);
    padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15);
    font-size: 14px;
  }
  .hud {
    position: fixed; left: 10px; top: 10px; z-index: 5; font-size: 14px; opacity: 0.9;
    padding: 6px 8px; background: rgba(0,0,0,0.25); border-radius: 8px; border: 1px solid rgba(255,255,255,0.12);
  }
  #wrap { flex: 1; position: relative; }
  canvas { position: absolute; inset: 0; width: 100vw; height: calc(100dvh - var(--controls-h)); touch-action: none; display: block; }

  .controls {
    height: var(--controls-h);
    width: 100vw;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
    padding: 8px 10px calc(8px + env(safe-area-inset-bottom));
    background: linear-gradient(180deg, rgba(0,0,0,0.0), rgba(0,0,0,0.35));
    backdrop-filter: blur(4px);
    transform: translateY(-20px); /* pulsanti 20px piÃ¹ in alto */
  }
  .btn {
    min-height: 50px;
    padding: 20px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.06);
    color: var(--ink);
    font-weight: 600; font-size: 16px;
    display: flex; align-items: center; justify-content: center;
    user-select: none;
  }
  .btn:active { transform: scale(0.98); }
  .col { display: flex; gap: 8px; }
  .col.left { justify-content: flex-start; }
  .col.center { justify-content: center; }
  .col.right { justify-content: flex-end; }

  .ghost-spot {
    width: 46%;
    min-height: 50px;
    border-radius: 14px;
    border: 1px dashed rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.02);
    visibility: hidden;
  }
  .hidden-btn { display: none; }
</style>
</head>
<body>
  <div class="topbar">
    <a class="upgrades" href="/match3/upgrades.html">upgrades â†—</a>
  </div>
  <div class="hud" id="hud">Â§0 â€¢ 0:00</div>
  <div id="wrap">
    <canvas id="game"></canvas>
  </div>

  <div class="controls" id="controls">
    <div class="col left">
      <div class="btn" id="btnLeft">âŸµ LEFT</div>
    </div>
    <div class="col center">
      <div class="ghost-spot"></div>
      <div class="ghost-spot"></div>
      <div class="btn hidden-btn" id="btnBomb">ðŸ’£ BOMB</div>
      <div class="btn hidden-btn" id="btnBoost">âš¡ BOOST</div>
    </div>
    <div class="col right">
      <div class="btn" id="btnRight">RIGHT âŸ¶</div>
    </div>
  </div>

<script>
(() => {
  // ---------- Persistent Storage ----------
  const LS_KEY = 'vscroll.shooter.v1';
  const defaultSave = {
    money: 0,
    timeSec: 0,
    "bomb unlocked": false,
    "bomb type": "none",   // "screen" | "smart"
    "boost unlocked": false,
    "boost type": "none",
    "enemies unlocked": { basic: true, betterVisible: false },
    "level data": { level: 1, difficulty: 1, score: 0, bossesKilled: 0 }, // bossesKilled NEW
    "bullet type": "round",
    "bullet number": 1,
    "bullet spread": 0,    // degrees
    "bullet fire rate": 0.5, // shots/sec
    "spawn every": 1.2,
    "boss unlocked": false
  };

  function loadSave() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      let save = raw ? JSON.parse(raw) : {};
      // merge level data explicitly to preserve subkeys
      save["level data"] = { ...defaultSave["level data"], ...(save["level data"]||{}) };
      save = { ...defaultSave, ...save };
      for (const k of Object.keys(save)) {
        const v = save[k];
        localStorage.setItem(k, typeof v === 'object' ? JSON.stringify(v) : String(v));
      }
      localStorage.setItem(LS_KEY, JSON.stringify(save));
      return save;
    } catch(e) {
      localStorage.setItem(LS_KEY, JSON.stringify(defaultSave));
      for (const k of Object.keys(defaultSave)) {
        const v = defaultSave[k];
        localStorage.setItem(k, typeof v === 'object' ? JSON.stringify(v) : String(v));
      }
      return structuredClone(defaultSave);
    }
  }

  function commitSave(partial) {
    const save = { ...state.save, ...partial };
    // deep merge for level data
    if (partial["level data"]) {
      save["level data"] = { ...(state.save["level data"]||{}), ...partial["level data"] };
    }
    state.save = save;
    for (const [k, v] of Object.entries(partial)) {
      const val = (k === "level data") ? state.save["level data"] : v;
      localStorage.setItem(k, typeof val === 'object' ? JSON.stringify(val) : String(val));
    }
    localStorage.setItem(LS_KEY, JSON.stringify(state.save));
  }

  // ---------- Canvas ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas, { passive: true });
  resizeCanvas();

  // ---------- State ----------
  const hudEl = document.getElementById('hud');
  const state = {
    save: loadSave(),
    player: {
      x: 0.5, y: 0.85,
      speed: 0.5, // screen widths per second
      size: 20,
      moveLeft: false, moveRight: false,
    },
    bullets: [],
    enemyBullets: [], // boss bullets
    enemies: [],
    boss: null,            // <- current boss (or null)
    bossSpawnTimer: 0,     // seconds since last boss spawn attempt
    bossSpawnEvery: 10,    // spawn interval if unlocked and no boss present
    stars: [],
    lastShotAt: 0,
    spawnTimer: 0,
    spawnEvery: 1.2,
    t: 0,
    lastFrame: performance.now(),
    playtimeAccumulator: 0,

    // Bomb
    bombCooldownSec: 10,   // (rimasto come nel tuo aggiornamento)
    bombReadyAt: 0,
  };

  // initialize spawnEvery from LS if present
  state.spawnEvery = Number(localStorage.getItem("spawn every")) || state.save["spawn every"] || 1.2;

  // ---------- Input ----------
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnBomb  = document.getElementById('btnBomb');

  const press = (setter, val) => (e)=>{ e.preventDefault(); setter(val); };

  btnLeft.addEventListener('touchstart', press(v=>state.player.moveLeft=v,true), { passive:false });
  btnLeft.addEventListener('touchend',   press(v=>state.player.moveLeft=v,false), { passive:false });
  btnLeft.addEventListener('mousedown',  press(v=>state.player.moveLeft=v,true));
  btnLeft.addEventListener('mouseup',    press(v=>state.player.moveLeft=v,false));
  btnLeft.addEventListener('mouseleave', press(v=>state.player.moveLeft=v,false));

  btnRight.addEventListener('touchstart', press(v=>state.player.moveRight=v,true), { passive:false });
  btnRight.addEventListener('touchend',   press(v=>state.player.moveRight=v,false), { passive:false });
  btnRight.addEventListener('mousedown',  press(v=>state.player.moveRight=v,true));
  btnRight.addEventListener('mouseup',    press(v=>state.player.moveRight=v,false));
  btnRight.addEventListener('mouseleave', press(v=>state.player.moveRight=v,false));

  // ---------- Stars ----------
  function initStars() {
    state.stars = [];
    const count = Math.floor((canvas.clientWidth * canvas.clientHeight) / 8000);
    for (let i=0;i<count;i++){
      state.stars.push({
        x: Math.random()*canvas.clientWidth,
        y: Math.random()*canvas.clientHeight,
        s: Math.random()*1.5 + 0.5,
        v: Math.random()*40 + 20, // px/s
      });
    }
  }
  initStars();

  // ---------- Enemy spawn ----------
  function spawnEnemy() {
    const size = 24;
    const x = Math.random()*(canvas.clientWidth - size) + size/2;
    state.enemies.push({
      x, y: -size, size,
      speed: 70,
      hp: 2,
      color: '#000',
    });
  }

  // ---------- Boss ----------
  function spawnBoss() {
    // Base stats affected by kills so far
    const kills = state.save["level data"].bossesKilled || 0;
    const hp = 80 + kills;              // +1 HP per boss ucciso
    const reward = 200 + 5*kills;       // +5 Â§ per kill precedente
    const bulletDmg = 10 + 5*kills;     // +5 danno per kill precedente

    state.boss = {
      x: canvas.clientWidth * 0.5,
      y: canvas.clientHeight * 0.25,   // 1/4 dall'alto
      r: 25,                           // diametro 50
      speedX: 60,                      // px/s, lento
      dir: 1,                          // 1 â†’ destra, -1 â†’ sinistra
      hp,
      maxHp: hp,
      reward,
      bulletDmg,
      lastShotAt: state.t
    };
  }

  function drawHexagon(cx, cy, r, fill, stroke) {
    const sides = 6;
    ctx.beginPath();
    for (let i=0;i<sides;i++){
      const ang = -Math.PI/2 + i*(2*Math.PI/sides);
      const x = cx + Math.cos(ang)*r;
      const y = cy + Math.sin(ang)*r;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    if (fill){ ctx.fillStyle = fill; ctx.fill(); }
    if (stroke){ ctx.lineWidth = 2; ctx.strokeStyle = stroke; ctx.stroke(); }
  }

  function bossCircleHit(boss, bullet) {
    const dx = bullet.x - boss.x, dy = bullet.y - boss.y;
    return dx*dx + dy*dy <= (boss.r*boss.r);
  }

  function spawnBossBullet() {
    if (!state.boss) return;
    // bullet aimed at player center
    const px = state.player.x * canvas.clientWidth;
    const py = state.player.y * canvas.clientHeight - state.player.size;
    const dx = px - state.boss.x, dy = py - state.boss.y;
    const len = Math.hypot(dx,dy) || 1;
    const speed = 220; // px/s
    state.enemyBullets.push({
      x: state.boss.x,
      y: state.boss.y,
      vx: (dx/len)*speed,
      vy: (dy/len)*speed,
      r: 4,
      dmg: state.boss.bulletDmg
    });
  }

  // ---------- Shooting ----------
  function shootFan(centerX, centerY, count, stepDeg, speed=320) {
    const center = -Math.PI/2; // -90Â°
    const total = (count-1) * (stepDeg * Math.PI/180);
    const start = center - total/2;
    for (let i=0;i<count;i++){
      const angle = start + i*(stepDeg * Math.PI/180);
      state.bullets.push({
        x: centerX,
        y: centerY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: 4,
      });
    }
  }

  function maybeShoot() {
    const rate = state.save["bullet fire rate"]; // shots/sec
    const interval = 1 / Math.max(0.05, rate);
    if (state.t - state.lastShotAt >= interval) {
      state.lastShotAt = state.t;
      const num = Math.max(1, Math.floor(state.save["bullet number"]));
      const spreadDeg = state.save["bullet spread"];
      const spreadRad = spreadDeg * Math.PI / 180;
      const startAngle = -Math.PI/2 - spreadRad/2;
      const step = (num === 1) ? 0 : spreadRad / (num-1);
      for (let i=0;i<num;i++){
        const angle = startAngle + i*step;
        state.bullets.push({
          x: state.player.x * canvas.clientWidth,
          y: state.player.y * canvas.clientHeight - state.player.size - 4,
          vx: Math.cos(angle) * 200,
          vy: Math.sin(angle) * 300,
          r: 4,
        });
      }
    }
  }

  // ---------- Bomb logic ----------
  function bombReady() { return state.t >= state.bombReadyAt; }

  function triggerBomb() {
    if (!bombReady()) return;

    const type = state.save["bomb type"] || "screen";
    const px = state.player.x * canvas.clientWidth;
    const py = state.player.y * canvas.clientHeight - state.player.size - 6;

    if (type === "screen") {
      shootFan(px, py, 90, 1, 360);
    } else if (type === "smart") {
      // NOTE: specifica originale: 50; nel tuo aggiornamento c'era 500.
      // Riporto a 50 come da specifica precedente del design.
      for (let i=0;i<50;i++) spawnEnemy();
    }
    state.bombReadyAt = state.t + state.bombCooldownSec;
  }

  // ---------- Collisions ----------
  function bulletHitsEnemy(b, e) {
    const rx = e.x - e.size/2, ry = e.y - e.size/2, rw = e.size, rh = e.size;
    const cx = Math.max(rx, Math.min(b.x, rx+rw));
    const cy = Math.max(ry, Math.min(b.y, ry+rh));
    const dx = b.x - cx, dy = b.y - cy;
    return (dx*dx + dy*dy) <= (b.r*b.r);
  }

  function bulletHitsPlayer(b) {
    // approx triangle as circle around the tip/center
    const px = state.player.x * canvas.clientWidth;
    const py = state.player.y * canvas.clientHeight - state.player.size/2;
    const pr = state.player.size; // conservative
    const dx = b.x - px, dy = b.y - py;
    return (dx*dx + dy*dy) <= (pr*pr);
  }

  // ---------- Loop ----------
  function update() {
    const now = performance.now();
    const dt = Math.min(0.033, (now - state.lastFrame)/1000);
    state.lastFrame = now;
    state.t += dt;
    state.playtimeAccumulator += dt;

    // keep reading spawnEvery if user upgraded in another tab
    const se = Number(localStorage.getItem("spawn every"));
    if (!Number.isNaN(se) && se > 0) state.spawnEvery = se;

    // player move
    const move = (state.player.moveRight ? 1 : 0) - (state.player.moveLeft ? 1 : 0);
    if (move) {
      state.player.x += move * state.player.speed * dt;
      state.player.x = Math.max(0.05, Math.min(0.95, state.player.x));
    }

    // spawn normal enemies
    state.spawnTimer += dt;
    if (state.spawnTimer >= state.spawnEvery) {
      state.spawnTimer = 0;
      spawnEnemy();
    }

    // boss spawning
    if (state.save["boss unlocked"]) {
      if (!state.boss) {
        state.bossSpawnTimer += dt;
        if (state.bossSpawnTimer >= state.bossSpawnEvery) {
          state.bossSpawnTimer = 0;
          spawnBoss();
        }
      } else {
        // boss movement left-right
        state.boss.x += state.boss.dir * state.boss.speedX * dt;
        const margin = state.boss.r + 8;
        if (state.boss.x < margin) { state.boss.x = margin; state.boss.dir = 1; }
        if (state.boss.x > canvas.clientWidth - margin) { state.boss.x = canvas.clientWidth - margin; state.boss.dir = -1; }
        // boss shooting every 1s
        if (state.t - state.boss.lastShotAt >= 1) {
          state.boss.lastShotAt = state.t;
          spawnBossBullet();
        }
      }
    }

    // player bullets
    for (let i=state.bullets.length-1;i>=0;i--){
      const b = state.bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      if (b.y < -10 || b.x < -10 || b.x > canvas.clientWidth+10) { state.bullets.splice(i,1); continue; }

      // hit boss?
      if (state.boss && bossCircleHit(state.boss, b)) {
        state.bullets.splice(i,1);
        state.boss.hp -= 1;
        if (state.boss.hp <= 0) {
          // reward
          commitSave({
            money: (state.save.money||0) + state.boss.reward,
            "level data": { ...state.save["level data"], bossesKilled: (state.save["level data"].bossesKilled||0) + 1 }
          });
          state.boss = null;
        }
        continue;
      }

      // hit normal enemy?
      for (let j=state.enemies.length-1;j>=0;j--){
        const e = state.enemies[j];
        if (bulletHitsEnemy(b, e)) {
          state.bullets.splice(i,1);
          e.hp -= 1;
          if (e.hp <= 0) {
            commitSave({
              money: (state.save.money||0)+1,
              "level data": { ...state.save["level data"], score: (state.save["level data"].score||0)+1 }
            });
            state.enemies.splice(j,1);
          } else {
            e.color = '#5e0000';
          }
          break;
        }
      }
    }

    // enemies move down
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      e.y += e.speed * dt;
      if (e.y - e.size/2 > canvas.clientHeight + 40) state.enemies.splice(i,1);
    }

    // enemy (boss) bullets update & hit player
    for (let i=state.enemyBullets.length-1;i>=0;i--){
      const eb = state.enemyBullets[i];
      eb.x += eb.vx * dt;
      eb.y += eb.vy * dt;
      if (eb.x < -20 || eb.x > canvas.clientWidth+20 || eb.y < -20 || eb.y > canvas.clientHeight+20) {
        state.enemyBullets.splice(i,1); continue;
      }
      if (bulletHitsPlayer(eb)) {
        // damage as loss of money
        const newMoney = Math.max(0, (state.save.money||0) - eb.dmg);
        commitSave({ money: newMoney });
        state.enemyBullets.splice(i,1);
      }
    }

    // stars
    for (const s of state.stars) {
      s.y += s.v * dt;
      if (s.y > canvas.clientHeight) { s.y = -2; s.x = Math.random()*canvas.clientWidth; }
    }

    // player shooting
    maybeShoot();

    // time persistence
    if (state.playtimeAccumulator >= 1) {
      state.playtimeAccumulator -= 1;
      commitSave({ timeSec: (state.save.timeSec||0) + 1 });
    }
  }

  function draw() {
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // bg + stars
    ctx.fillStyle = '#0b0e13';
    ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    for (const s of state.stars) ctx.fillRect(s.x, s.y, s.s, s.s);

    // player
    const px = state.player.x * canvas.clientWidth;
    const py = state.player.y * canvas.clientHeight;
    const a = state.player.size;
    ctx.fillStyle = '#35c3ff';
    ctx.beginPath();
    ctx.moveTo(px, py - a);
    ctx.lineTo(px - a, py + a);
    ctx.lineTo(px + a, py + a);
    ctx.closePath();
    ctx.fill();

    // player bullets
    ctx.fillStyle = '#f5f7ff';
    for (const b of state.bullets) {
      ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
    }

    // enemies (better visible)
    const enemiesCfg = (()=>{try{return JSON.parse(localStorage.getItem("enemies unlocked")||'{}');}catch{return {};}})();
    const betterVisible = !!enemiesCfg.betterVisible;

    for (const e of state.enemies) {
      if (betterVisible) {
        ctx.save();
        ctx.shadowColor = 'rgba(255,255,255,0.6)';
        ctx.shadowBlur = 8;
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
        ctx.restore();
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.strokeRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
        ctx.restore();
      } else {
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
      }
      // HP pips (small squares above)
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      for (let i=0;i<e.hp;i++){
        ctx.fillRect(e.x - 6 + i*6 - 3, e.y - e.size/2 - 6, 4, 4);
      }
    }

    // boss
    if (state.boss) {
      // body
      const fill = '#7f1d1d';
      const stroke = '#ffffff';
      if (betterVisible) {
        ctx.save();
        ctx.shadowColor = 'rgba(255,255,255,0.7)';
        ctx.shadowBlur = 10;
        drawHexagon(state.boss.x, state.boss.y, state.boss.r, fill, stroke);
        ctx.restore();
      } else {
        drawHexagon(state.boss.x, state.boss.y, state.boss.r, fill, stroke);
      }

      // HP indicator: one tick per 10 HP remaining (maxHp/10)
      const ticksTotal = Math.ceil(state.boss.maxHp / 10);
      const ticksLeft = Math.ceil(Math.max(0, state.boss.hp) / 10);
      const barW = 6