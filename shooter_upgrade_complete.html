<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Vertical Scroll Shooter</title>
<style>
  :root{
    --controls-h: 64px; /* >= 50px */
    --bg: #0b0e13;
    --ink: #e6e6e6;
    --accent: #35c3ff;
  }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
  body { display: flex; flex-direction: column; overflow: hidden; }
  /* Layout: canvas full height minus controls */
  .topbar{
    position: fixed; inset: env(safe-area-inset-top) 0 auto 0;
    height: 44px; display: flex; align-items: center; justify-content: flex-end;
    padding: 0 12px calc(env(safe-area-inset-top));
    pointer-events: none; z-index: 5;
  }
  .topbar a.upgrades {
    pointer-events: auto;
    text-decoration: none; background: rgba(255,255,255,0.08);
    padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15);
    font-size: 14px;
  }
  .hud {
    position: fixed; left: 10px; top: 10px; z-index: 5; font-size: 14px; opacity: 0.9;
    padding: 6px 8px; background: rgba(0,0,0,0.25); border-radius: 8px; border: 1px solid rgba(255,255,255,0.12);
  }
  #wrap { flex: 1; position: relative; }
  canvas { position: absolute; inset: 0; width: 100vw; height: calc(100dvh - var(--controls-h)); touch-action: none; display: block; }
  .controls {
    height: var(--controls-h);
    width: 100vw;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
    padding: 8px 10px calc(8px + env(safe-area-inset-bottom));
    background: linear-gradient(180deg, rgba(0,0,0,0.0), rgba(0,0,0,0.35));
    backdrop-filter: blur(4px);
  }
  .btn {
    min-height: 50px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.06);
    color: var(--ink);
    font-weight: 600; font-size: 16px;
    display: flex; align-items: center; justify-content: center;
    user-select: none;
  }
  .btn:active { transform: scale(0.98); }
  /* Left and Right are visible, center contains reserved space + hidden buttons */
  .col { display: flex; gap: 8px; }
  .col.left { justify-content: flex-start; }
  .col.center { justify-content: center; }
  .col.right { justify-content: flex-end; }

  /* Reserve space for two hidden buttons (layout placeholder) */
  .ghost-spot {
    width: 46%; /* two spots roughly side-by-side */
    min-height: 50px;
    border-radius: 14px;
    border: 1px dashed rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.02);
    visibility: hidden; /* keeps the space */
  }

  /* Hidden actual buttons (ready to be revealed later by code if unlocked) */
  .hidden-btn { display: none; }

  /* Mobile-friendly hit areas */
  .btn, .ghost-spot { touch-action: manipulation; }
</style>
</head>
<body>
  <div class="topbar">
    <a class="upgrades" href="/upgrades.html">upgrades â†—</a>
  </div>
  <div class="hud" id="hud">Â§0 â€¢ 0:00</div>
  <div id="wrap">
    <canvas id="game"></canvas>
  </div>

  <div class="controls" id="controls">
    <div class="col left">
      <div class="btn" id="btnLeft">âŸµ LEFT</div>
    </div>
    <div class="col center">
      <!-- keep space for two middle buttons (bomb/boost) even if hidden -->
      <div class="ghost-spot"></div>
      <div class="ghost-spot"></div>

      <div class="btn hidden-btn" id="btnBomb">ðŸ’£ BOMB</div>
      <div class="btn hidden-btn" id="btnBoost">âš¡ BOOST</div>
    </div>
    <div class="col right">
      <div class="btn" id="btnRight">RIGHT âŸ¶</div>
    </div>
  </div>

<script>
(() => {
  // ---------- Persistent Storage Helpers ----------
  const LS_KEY = 'vscroll.shooter.v1'; // pack everything in one object *and* mirror named keys for direct reads
  const defaultSave = {
    money: 0,                 // integer "Â§"
    timeSec: 0,               // total play time
    // meta / unlocks
    "bomb unlocked": false,
    "bomb type": "none",      // e.g., "smart","screen","nuke"
    "boost unlocked": false,
    "boost type": "none",     // e.g., "speed","shield"
    "enemies unlocked": { basic: true }, // structure expandable
    "level data": { level: 1, difficulty: 1, score: 0 },
    // bullets config
    "bullet type": "round",
    "bullet number": 1,       // parallel bullets per shot
    "bullet spread": 0,       // degrees total spread
    "bullet fire rate": 0.5,  // shots per second (default = 0.5 => every 2s)
  };

  function loadSave() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      let save = raw ? JSON.parse(raw) : {};
      // Also mirror legacy/simple keys if present
      save = { ...defaultSave, ...save };
      // expose mirror keys as separate entries (as requested)
      for (const k of Object.keys(defaultSave)) {
        const v = save[k];
        if (typeof v === 'object') {
          localStorage.setItem(k, JSON.stringify(v));
        } else {
          localStorage.setItem(k, String(v));
        }
      }
      // also keep the packed object
      localStorage.setItem(LS_KEY, JSON.stringify(save));
      return save;
    } catch(e) {
      console.warn('Load save failed, resetting', e);
      localStorage.clear();
      localStorage.setItem(LS_KEY, JSON.stringify(defaultSave));
      for (const k of Object.keys(defaultSave)) {
        const v = defaultSave[k];
        localStorage.setItem(k, typeof v === 'object' ? JSON.stringify(v) : String(v));
      }
      return structuredClone(defaultSave);
    }
  }

  function commitSave(partial) {
    const save = { ...state.save, ...partial };
    state.save = save;
    // mirror simple keys
    for (const [k, v] of Object.entries(partial)) {
      if (typeof v === 'object') localStorage.setItem(k, JSON.stringify(v));
      else localStorage.setItem(k, String(v));
    }
    localStorage.setItem(LS_KEY, JSON.stringify(save));
  }

  // ---------- Canvas + DPR ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // so we can draw in CSS pixels
  }
  window.addEventListener('resize', resizeCanvas, { passive: true });
  resizeCanvas();

  // ---------- State ----------
  const hudEl = document.getElementById('hud');
  const state = {
    save: loadSave(),
    player: {
      x: 0.5, // normalized [0..1] of canvas width
      y: 0.85, // relative to canvas height
      speed: 0.5, // in screen widths per second
      size: 20, // triangle half-base in px
      moveLeft: false,
      moveRight: false,
    },
    bullets: [],
    enemies: [],
    stars: [],
    lastShotAt: 0,
    spawnTimer: 0,
    spawnEvery: 1.2, // seconds between spawns
    t: 0,
    lastFrame: performance.now(),
    playtimeAccumulator: 0, // accumulate and flush to save once per second
  };

  // ---------- Input ----------
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');

  function pressLeft(v){ state.player.moveLeft = v; }
  function pressRight(v){ state.player.moveRight = v; }

  // Touch & mouse handlers
  const press = (fn) => (e) => { e.preventDefault(); fn(true); };
  const release = (fn) => (e) => { e.preventDefault(); fn(false); };

  btnLeft.addEventListener('touchstart', press(pressLeft), { passive: false });
  btnLeft.addEventListener('touchend', release(pressLeft), { passive: false });
  btnLeft.addEventListener('mousedown', press(pressLeft));
  btnLeft.addEventListener('mouseup', release(pressLeft));
  btnLeft.addEventListener('mouseleave', release(pressLeft));

  btnRight.addEventListener('touchstart', press(pressRight), { passive: false });
  btnRight.addEventListener('touchend', release(pressRight), { passive: false });
  btnRight.addEventListener('mousedown', press(pressRight));
  btnRight.addEventListener('mouseup', release(pressRight));
  btnRight.addEventListener('mouseleave', release(pressRight));

  // ---------- Stars (scrolling background) ----------
  function initStars() {
    state.stars = [];
    const count = Math.floor((canvas.clientWidth * canvas.clientHeight) / 8000);
    for (let i=0;i<count;i++){
      state.stars.push({
        x: Math.random()*canvas.clientWidth,
        y: Math.random()*canvas.clientHeight,
        s: Math.random()*1.5 + 0.5,
        v: Math.random()*40 + 20, // px/s
      });
    }
  }
  initStars();

  // ---------- Enemy spawning ----------
  function spawnEnemy() {
    const size = 24;
    const x = Math.random()*(canvas.clientWidth - size) + size/2;
    state.enemies.push({
      x, y: -size, size,
      speed: 70, // px/s downward
      hp: 2,
      color: '#000', // black initially
    });
  }

  // ---------- Shooting ----------
  function maybeShoot(dt) {
    const rate = state.save["bullet fire rate"]; // shots per second
    const interval = 1 / Math.max(0.05, rate); // protect from zero/neg
    if (state.t - state.lastShotAt >= interval) {
      state.lastShotAt = state.t;
      const num = Math.max(1, Math.floor(state.save["bullet number"]));
      const spreadDeg = state.save["bullet spread"];
      const spreadRad = spreadDeg * Math.PI / 180;
      const startAngle = -Math.PI/2 - spreadRad/2;
      const step = (num === 1) ? 0 : spreadRad / (num-1);
      for (let i=0;i<num;i++){
        const angle = startAngle + i*step;
        state.bullets.push({
          x: state.player.x * canvas.clientWidth,
          y: state.player.y * canvas.clientHeight - state.player.size - 4,
          vx: Math.cos(angle)*0, // mostly vertical shot
          vy: Math.sin(angle)*300, // negative (upwards), but sin(-90Â°) = -1
          r: 4,
        });
      }
    }
  }

  // ---------- Collisions ----------
  function bulletHitsEnemy(b, e) {
    // Circle-rectangle overlap (AABB)
    const rx = e.x - e.size/2;
    const ry = e.y - e.size/2;
    const rw = e.size;
    const rh = e.size;
    const cx = Math.max(rx, Math.min(b.x, rx+rw));
    const cy = Math.max(ry, Math.min(b.y, ry+rh));
    const dx = b.x - cx;
    const dy = b.y - cy;
    return (dx*dx + dy*dy) <= (b.r*b.r);
  }

  // ---------- Loop ----------
  function update() {
    const now = performance.now();
    const dt = Math.min(0.033, (now - state.lastFrame)/1000); // clamp
    state.lastFrame = now;
    state.t += dt;
    state.playtimeAccumulator += dt;

    // player move
    const move = (state.player.moveRight ? 1 : 0) - (state.player.moveLeft ? 1 : 0);
    if (move !== 0) {
      state.player.x += move * state.player.speed * dt;
      state.player.x = Math.max(0.05, Math.min(0.95, state.player.x));
    }

    // spawn enemies
    state.spawnTimer += dt;
    if (state.spawnTimer >= state.spawnEvery) {
      state.spawnTimer = 0;
      spawnEnemy();
    }

    // bullets
    for (let i=state.bullets.length-1;i>=0;i--){
      const b = state.bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt; // vy is negative (up)
      if (b.y < -10) { state.bullets.splice(i,1); continue; }
    }

    // enemies
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      e.y += e.speed * dt;
      if (e.y - e.size/2 > canvas.clientHeight + 40) {
        state.enemies.splice(i,1); continue;
      }
    }

    // collisions bullet-enemy
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      let hitIndex = -1;
      for (let j=state.bullets.length-1;j>=0;j--){
        if (bulletHitsEnemy(state.bullets[j], e)) { hitIndex = j; break; }
      }
      if (hitIndex >= 0) {
        // consume bullet
        state.bullets.splice(hitIndex,1);
        // damage enemy
        e.hp -= 1;
        if (e.hp <= 0) {
          // dead -> money +1Â§
          const newMoney = (state.save.money||0) + 1;
          commitSave({ money: newMoney, "level data": { ...state.save["level data"], score: (state.save["level data"].score||0) + 1 } });
          state.enemies.splice(i,1);
        } else {
          e.color = '#5e0000'; // dark red
        }
      }
    }

    // stars
    for (const s of state.stars) {
      s.y += s.v * dt;
      if (s.y > canvas.clientHeight) { s.y = -2; s.x = Math.random()*canvas.clientWidth; }
    }

    // shooting
    maybeShoot(dt);

    // playtime persistence every ~1s
    if (state.playtimeAccumulator >= 1) {
      state.playtimeAccumulator -= 1;
      commitSave({ timeSec: (state.save.timeSec||0) + 1 });
    }
  }

  function draw() {
    // clear
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // background
    ctx.fillStyle = '#0b0e13';
    ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    for (const s of state.stars) {
      ctx.fillRect(s.x, s.y, s.s, s.s);
    }

    // player (triangle up)
    const px = state.player.x * canvas.clientWidth;
    const py = state.player.y * canvas.clientHeight;
    const a = state.player.size;
    ctx.fillStyle = '#35c3ff';
    ctx.beginPath();
    ctx.moveTo(px, py - a);     // top
    ctx.lineTo(px - a, py + a); // bottom-left
    ctx.lineTo(px + a, py + a); // bottom-right
    ctx.closePath();
    ctx.fill();

    // bullets (round)
    ctx.fillStyle = '#f5f7ff';
    for (const b of state.bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }

    // enemies
    for (const e of state.enemies) {
      ctx.fillStyle = e.color;
      ctx.fillRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
      // small HP pip
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      for (let i=0;i<e.hp;i++){
        ctx.fillRect(e.x - 6 + i*6 - 3, e.y - e.size/2 - 6, 4, 4);
      }
    }

    // HUD
    const m = state.save.money || 0;
    const ts = state.save.timeSec || 0;
    const mm = Math.floor(ts/60), ss = ts % 60;
    hudEl.textContent = `Â§${m} â€¢ ${mm}:${String(ss).padStart(2,'0')}`;
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  // ---------- Ensure middle hidden buttons can be revealed later ----------
  function checkUnlocksAndToggleButtons() {
    const bombUnlocked = !!state.save["bomb unlocked"];
    const boostUnlocked = !!state.save["boost unlocked"];
    const btnBomb = document.getElementById('btnBomb');
    const btnBoost = document.getElementById('btnBoost');

    // Show/hide with layout preserved (we already have ghost spots to keep space pre-allocated)
    btnBomb.style.display = bombUnlocked ? 'flex' : 'none';
    btnBoost.style.display = boostUnlocked ? 'flex' : 'none';
  }
  checkUnlocksAndToggleButtons();

  // ---------- Start ----------
  loop();

  // ---------- Visibility handling (optional small optimization) ----------
  document.addEventListener('visibilitychange', () => {
    state.lastFrame = performance.now();
  });

  // ---------- Expose a tiny debug API in console ----------
  window.vscroll = {
    addMoney(n=1){ commitSave({ money: (state.save.money||0)+n }); },
    setFireRate(r){ commitSave({ "bullet fire rate": r }); },
    setBullets(n, spread=0){ commitSave({ "bullet number": n, "bullet spread": spread }); },
    unlockBomb(type="screen"){ commitSave({ "bomb unlocked": true, "bomb type": type }); checkUnlocksAndToggleButtons(); },
    unlockBoost(type="speed"){ commitSave({ "boost unlocked": true, "boost type": type }); checkUnlocksAndToggleButtons(); },
    save: () => state.save
  };
})();
</script>
</body>
</html>