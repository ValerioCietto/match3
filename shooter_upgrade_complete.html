<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Vertical Scroll Shooter</title>
<style>
  :root{
    --controls-h: 64px; /* >= 50px */
    --bg: #0b0e13;
    --ink: #e6e6e6;
    --accent: #35c3ff;
    --lift: 20px; /* controls raised by 20px */
  }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans"; }
  body { display: flex; flex-direction: column; overflow: hidden; }

  .topbar{
    position: fixed; inset: env(safe-area-inset-top) 0 auto 0;
    height: 44px; display: flex; align-items: center; justify-content: flex-end;
    padding: 0 12px calc(env(safe-area-inset-top));
    pointer-events: none; z-index: 5;
  }
  .topbar a.upgrades {
    pointer-events: auto;
    text-decoration: none; background: rgba(255,255,255,0.08);
    padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15);
    font-size: 14px;
  }
  .hud {
    position: fixed; left: 10px; top: 10px; z-index: 5; font-size: 14px; opacity: 0.9;
    padding: 6px 8px; background: rgba(0,0,0,0.25); border-radius: 8px; border: 1px solid rgba(255,255,255,0.12);
  }
  #wrap { flex: 1; position: relative; }
  /* Raise controls visually by 20px and give that 20px back to the canvas to avoid a gap */
  canvas { position: absolute; inset: 0; width: 100vw; height: calc(100dvh - var(--controls-h) + var(--lift)); touch-action: none; display: block; }
  .controls {
    height: var(--controls-h);
    width: 100vw;
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
    padding: 8px 10px calc(8px + env(safe-area-inset-bottom));
    background: linear-gradient(180deg, rgba(0,0,0,0.0), rgba(0,0,0,0.35));
    backdrop-filter: blur(4px);
    transform: translateY(calc(-1 * var(--lift))); /* visually 20px higher */
  }
  .btn {
    min-height: 50px;
    padding: 20px; /* larger touch targets */
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.06);
    color: var(--ink);
    font-weight: 600; font-size: 16px;
    display: flex; align-items: center; justify-content: center;
    user-select: none;
  }
  .btn:active { transform: scale(0.98); }
  .col { display: flex; gap: 8px; }
  .col.left { justify-content: flex-start; }
  .col.center { justify-content: center; }
  .col.right { justify-content: flex-end; }

  /* reserved space for future middle buttons */
  .ghost-spot {
    width: 46%;
    min-height: 50px;
    border-radius: 14px;
    border: 1px dashed rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.02);
    visibility: hidden;
  }
  .hidden-btn { display: none; }
</style>
</head>
<body>
  <div class="topbar">
    <a class="upgrades" href="/match3/upgrades.html">upgrades â†—</a>
  </div>
  <div class="hud" id="hud">Â§0 â€¢ 0:00</div>
  <div id="wrap">
    <canvas id="game"></canvas>
  </div>

  <div class="controls" id="controls">
    <div class="col left">
      <div class="btn" id="btnLeft">âŸµ LEFT</div>
    </div>
    <div class="col center">
      <div class="ghost-spot"></div>
      <div class="ghost-spot"></div>
      <div class="btn hidden-btn" id="btnBomb">ðŸ’£ BOMB</div>
      <div class="btn hidden-btn" id="btnBoost">âš¡ BOOST</div>
    </div>
    <div class="col right">
      <div class="btn" id="btnRight">RIGHT âŸ¶</div>
    </div>
  </div>

<script>
(() => {
  // ---------- Persistent Storage ----------
  const LS_KEY = 'vscroll.shooter.v1';
  const defaultSave = {
    money: 0,
    timeSec: 0,
    "bomb unlocked": false,
    "bomb type": "none",   // "screen" | "smart"
    "boost unlocked": false,
    "boost type": "none",
    "enemies unlocked": { basic: true, betterVisible: false },
    "level data": { level: 1, difficulty: 1, score: 0 },
    "bullet type": "round",
    "bullet number": 1,
    "bullet spread": 0,        // degrees
    "bullet fire rate": 0.5,   // shots/sec
    "spawn every": 1.2,        // seconds (upgrades can change this)
    "boss unlocked": false
  };

  function loadSave() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      let save = raw ? JSON.parse(raw) : {};
      save = { ...defaultSave, ...save };
      for (const k of Object.keys(save)) {
        const v = save[k];
        localStorage.setItem(k, typeof v === 'object' ? JSON.stringify(v) : String(v));
      }
      localStorage.setItem(LS_KEY, JSON.stringify(save));
      return save;
    } catch(e) {
      localStorage.setItem(LS_KEY, JSON.stringify(defaultSave));
      for (const k of Object.keys(defaultSave)) {
        const v = defaultSave[k];
        localStorage.setItem(k, typeof v === 'object' ? JSON.stringify(v) : String(v));
      }
      return structuredClone(defaultSave);
    }
  }

  function commitSave(partial) {
    const save = { ...state.save, ...partial };
    state.save = save;
    for (const [k, v] of Object.entries(partial)) {
      localStorage.setItem(k, typeof v === 'object' ? JSON.stringify(v) : String(v));
    }
    localStorage.setItem(LS_KEY, JSON.stringify(save));
  }

  // ---------- Canvas ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resizeCanvas, { passive: true });
  resizeCanvas();

  // ---------- State ----------
  const hudEl = document.getElementById('hud');
  const state = {
    save: loadSave(),
    player: {
      x: 0.5, y: 0.85,
      speed: 0.5, // screen widths per second
      size: 20,
      moveLeft: false, moveRight: false,
    },
    bullets: [],
    enemies: [],
    stars: [],
    lastShotAt: 0,
    spawnTimer: 0,
    t: 0,
    lastFrame: performance.now(),
    playtimeAccumulator: 0,

    // Bomb
    bombCooldownSec: 60,
    bombReadyAt: 0, // timestamp (seconds)

    // Boss
    boss: null,         // {x,y,flat,hp,speed,drift}
    bossSpawnTimer: 0,  // seconds since last eligible spawn
    moneyDamageAccumulator: 0 // for laser -1Â§/s
  };

  // ---------- Input ----------
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnBomb  = document.getElementById('btnBomb');

  const press = (setter, val) => (e)=>{ e.preventDefault(); setter(val); };

  btnLeft.addEventListener('touchstart', press(v=>state.player.moveLeft=v,true), { passive:false });
  btnLeft.addEventListener('touchend',   press(v=>state.player.moveLeft=v,false), { passive:false });
  btnLeft.addEventListener('mousedown',  press(v=>state.player.moveLeft=v,true));
  btnLeft.addEventListener('mouseup',    press(v=>state.player.moveLeft=v,false));
  btnLeft.addEventListener('mouseleave', press(v=>state.player.moveLeft=v,false));

  btnRight.addEventListener('touchstart', press(v=>state.player.moveRight=v,true), { passive:false });
  btnRight.addEventListener('touchend',   press(v=>state.player.moveRight=v,false), { passive:false });
  btnRight.addEventListener('mousedown',  press(v=>state.player.moveRight=v,true));
  btnRight.addEventListener('mouseup',    press(v=>state.player.moveRight=v,false));
  btnRight.addEventListener('mouseleave', press(v=>state.player.moveRight=v,false));

  // ---------- Stars ----------
  function initStars() {
    state.stars = [];
    const count = Math.floor((canvas.clientWidth * canvas.clientHeight) / 8000);
    for (let i=0;i<count;i++){
      state.stars.push({
        x: Math.random()*canvas.clientWidth,
        y: Math.random()*canvas.clientHeight,
        s: Math.random()*1.5 + 0.5,
        v: Math.random()*40 + 20, // px/s
      });
    }
  }
  initStars();

  // ---------- Enemy spawn ----------
  function spawnEnemy() {
    const size = 24;
    const x = Math.random()*(canvas.clientWidth - size) + size/2;
    state.enemies.push({
      x, y: -size, size,
      speed: 70,
      hp: 2,
      color: '#000',
    });
  }

  // ---------- Boss spawn / update ----------
  function spawnBoss() {
    // Boss with exact flat-to-flat = 50px
    const flat = 50;
    state.boss = {
      x: canvas.clientWidth * 0.5,
      y: -flat,
      flat,             // flat-to-flat distance
      hp: 80,
      speed: 40,        // downward until in place
      drift: (Math.random()<0.5?-1:1)*(30+Math.random()*30) // horizontal sway px/s
    };
  }

  function updateBoss(dt) {
    const b = state.boss;
    if (!b) return;

    // Move boss: down then slight horizontal sway
    b.y += b.speed * dt;
    b.x += b.drift * dt;
    if (b.x < 40 || b.x > canvas.clientWidth-40) b.drift *= -1; // bounce horizontally
    // Stop vertical descent after entering the screen a bit
    if (b.y > canvas.clientHeight*0.18) b.speed = 0;

    // Laser damage: -1 Â§ / second while boss exists
    if ((state.save.money|0) > 0) {
      state.moneyDamageAccumulator += dt;
      while (state.moneyDamageAccumulator >= 1 && (state.save.money|0) > 0) {
        state.moneyDamageAccumulator -= 1;
        commitSave({ money: Math.max(0, (state.save.money|0) - 1) });
      }
    }
  }

  function drawBoss() {
    const b = state.boss;
    if (!b) return;

    // laser from boss to player
    const px = state.player.x * canvas.clientWidth;
    const py = state.player.y * canvas.clientHeight;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,30,30,0.9)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(b.x, b.y);
    ctx.lineTo(px, py);
    ctx.stroke();
    ctx.restore();

    // Draw regular hexagon with flat-to-flat = b.flat
    // For a regular hexagon: apothem a = flat/2; circumradius R = a / (âˆš3/2) = flat / âˆš3
    const a = b.flat / 2;
    const R = b.flat / Math.sqrt(3);
    const sides = 6;
    ctx.save();
    ctx.fillStyle = '#222';
    ctx.strokeStyle = '#ff4040';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i=0;i<sides;i++){
      const ang = -Math.PI/2 + i*(Math.PI*2/sides); // point-up orientation
      const vx = b.x + R*Math.cos(ang);
      const vy = b.y + R*Math.sin(ang);
      if (i===0) ctx.moveTo(vx,vy); else ctx.lineTo(vx,vy);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // HP squares (1 per 10 HP) centered at top
    const squares = Math.max(0, Math.floor(b.hp / 10));
    const size = 14, gap = 6;
    const totalW = squares*size + (squares-1)*gap;
    const startX = (canvas.clientWidth - totalW)/2;
    const y = 8 + 10;
    for (let i=0;i<squares;i++){
      ctx.fillStyle = '#ff6b6b';
      ctx.fillRect(startX + i*(size+gap), y, size, size);
    }
  }

  // Bullet vs Boss collision (approx circle using circumradius R)
  function bulletHitsBoss(bul, boss) {
    const R = boss.flat / Math.sqrt(3);
    const dx = bul.x - boss.x;
    const dy = bul.y - boss.y;
    return (dx*dx + dy*dy) <= (R*R);
  }

  // ---------- Shooting ----------
  function shootFan(centerX, centerY, count, stepDeg, speed=320) {
    const center = -Math.PI/2; // -90Â°
    const total = (count-1) * (stepDeg * Math.PI/180);
    const start = center - total/2;
    for (let i=0;i<count;i++){
      const angle = start + i*(stepDeg * Math.PI/180);
      state.bullets.push({
        x: centerX,
        y: centerY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: 4,
      });
    }
  }

  function maybeShoot() {
    const rate = state.save["bullet fire rate"]; // shots/sec
    const interval = 1 / Math.max(0.05, rate);
    if (state.t - state.lastShotAt >= interval) {
      state.lastShotAt = state.t;
      const num = Math.max(1, Math.floor(state.save["bullet number"]));
      const spreadDeg = state.save["bullet spread"];
      const spreadRad = spreadDeg * Math.PI / 180;
      const startAngle = -Math.PI/2 - spreadRad/2;
      const step = (num === 1) ? 0 : spreadRad / (num-1);
      for (let i=0;i<num;i++){
        const angle = startAngle + i*step;
        state.bullets.push({
          x: state.player.x * canvas.clientWidth,
          y: state.player.y * canvas.clientHeight - state.player.size - 4,
          vx: Math.cos(angle) * 200, // allow lateral component for spread
          vy: Math.sin(angle) * 300, // upward (negative)
          r: 4,
        });
      }
    }
  }

  // ---------- Bomb logic ----------
  function bombReady() { return state.t >= state.bombReadyAt; }

  function triggerBomb() {
    if (!bombReady()) return;
    const type = state.save["bomb type"] || "screen";
    const px = state.player.x * canvas.clientWidth;
    const py = state.player.y * canvas.clientHeight - state.player.size - 6;

    if (type === "screen") {
      // 90 bullets, step 1Â°
      shootFan(px, py, 90, 1, 360);
    } else if (type === "smart") {
      for (let i=0;i<50;i++) spawnEnemy();
    }
    state.bombReadyAt = state.t + state.bombCooldownSec;
  }

  // ---------- Collisions ----------
  function bulletHitsEnemy(b, e) {
    const rx = e.x - e.size/2, ry = e.y - e.size/2, rw = e.size, rh = e.size;
    const cx = Math.max(rx, Math.min(b.x, rx+rw));
    const cy = Math.max(ry, Math.min(b.y, ry+rh));
    const dx = b.x - cx, dy = b.y - cy;
    return (dx*dx + dy*dy) <= (b.r*b.r);
  }

  // ---------- Loop ----------
  function update() {
    const now = performance.now();
    const dt = Math.min(0.033, (now - state.lastFrame)/1000);
    state.lastFrame = now;
    state.t += dt;
    state.playtimeAccumulator += dt;

    // current spawn cadence from save
    const spawnEvery = Number(state.save["spawn every"] ?? 1.2) || 1.2;

    // player move
    const move = (state.player.moveRight ? 1 : 0) - (state.player.moveLeft ? 1 : 0);
    if (move) {
      state.player.x += move * state.player.speed * dt;
      state.player.x = Math.max(0.05, Math.min(0.95, state.player.x));
    }

    // spawn basic enemies
    state.spawnTimer += dt;
    if (state.spawnTimer >= spawnEvery) {
      state.spawnTimer = 0;
      spawnEnemy();
    }

    // boss spawn (only if unlocked and none present)
    if (!state.boss && !!state.save["boss unlocked"]) {
      state.bossSpawnTimer += dt;
      const bossPeriod = Math.max(0.1, spawnEvery) * 10; // 10Ã— basic cooldown
      if (state.bossSpawnTimer >= bossPeriod) {
        state.bossSpawnTimer = 0;
        spawnBoss();
      }
    }

    // bullets
    for (let i=state.bullets.length-1;i>=0;i--){
      const bl = state.bullets[i];
      bl.x += bl.vx * dt;
      bl.y += bl.vy * dt;
      if (bl.y < -10 || bl.x < -10 || bl.x > canvas.clientWidth+10) state.bullets.splice(i,1);
    }

    // enemies
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      e.y += e.speed * dt;
      if (e.y - e.size/2 > canvas.clientHeight + 40) state.enemies.splice(i,1);
    }

    // collisions bullet-enemy
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      let hitIndex = -1;
      for (let j=state.bullets.length-1;j>=0;j--){
        if (bulletHitsEnemy(state.bullets[j], e)) { hitIndex = j; break; }
      }
      if (hitIndex >= 0) {
        state.bullets.splice(hitIndex,1);
        e.hp -= 1;
        if (e.hp <= 0) {
          commitSave({ money: (state.save.money|0)+1,
            "level data": { ...state.save["level data"], score: (state.save["level data"].score||0)+1 }
          });
          state.enemies.splice(i,1);
        } else {
          e.color = '#5e0000';
        }
      }
    }

    // boss update & bullet collisions
    if (state.boss) {
      updateBoss(dt);

      for (let j=state.bullets.length-1;j>=0;j--){
        const bl = state.bullets[j];
        if (bulletHitsBoss(bl, state.boss)) {
          state.bullets.splice(j,1);
          state.boss.hp -= 1;
          if (state.boss.hp <= 0) {
            commitSave({ money: (state.save.money|0) + 200 });
            state.boss = null;
            break;
          }
        }
      }

      // remove boss if it somehow leaves the screen at bottom
      if (state.boss && state.boss.y - state.boss.flat/2 > canvas.clientHeight + 60) {
        state.boss = null;
      }
    }

    // stars
    for (const s of state.stars) {
      s.y += s.v * dt;
      if (s.y > canvas.clientHeight) { s.y = -2; s.x = Math.random()*canvas.clientWidth; }
    }

    // shooting
    maybeShoot();

    // time persistence
    if (state.playtimeAccumulator >= 1) {
      state.playtimeAccumulator -= 1;
      commitSave({ timeSec: (state.save.timeSec|0) + 1 });
    }
  }

  function draw() {
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // bg + stars
    ctx.fillStyle = '#0b0e13';
    ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    for (const s of state.stars) ctx.fillRect(s.x, s.y, s.s, s.s);

    // player
    const px = state.player.x * canvas.clientWidth;
    const py = state.player.y * canvas.clientHeight;
    const a = state.player.size;
    ctx.fillStyle = '#35c3ff';
    ctx.beginPath();
    ctx.moveTo(px, py - a);
    ctx.lineTo(px - a, py + a);
    ctx.lineTo(px + a, py + a);
    ctx.closePath();
    ctx.fill();

    // bullets
    ctx.fillStyle = '#f5f7ff';
    for (const b of state.bullets) {
      ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
    }

    // enemies (better visible)
    const enemiesCfg = (()=>{try{return JSON.parse(localStorage.getItem("enemies unlocked")||'{}');}catch{return {};}})();
    const betterVisible = !!enemiesCfg.betterVisible;

    for (const e of state.enemies) {
      if (betterVisible) {
        ctx.save();
        ctx.shadowColor = 'rgba(255,255,255,0.6)';
        ctx.shadowBlur = 8;
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
        ctx.restore();
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.strokeRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
        ctx.restore();
      } else {
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x - e.size/2, e.y - e.size/2, e.size, e.size);
      }
      // HP pips
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      for (let i=0;i<e.hp;i++){
        ctx.fillRect(e.x - 6 + i*6 - 3, e.y - e.size/2 - 6, 4, 4);
      }
    }

    // boss draw (laser + hexagon + HP squares)
    drawBoss();

    // HUD
    const m = state.save.money || 0;
    const ts = state.save.timeSec || 0;
    const mm = Math.floor(ts/60), ss = ts % 60;
    hudEl.textContent = `Â§${m} â€¢ ${mm}:${String(ss).padStart(2,'0')}`;

    // Bomb button UI (cooldown)
    if (btnBomb) {
      const unlocked = !!state.save["bomb unlocked"];
      const type = state.save["bomb type"] || "screen";
      const cd = Math.ceil(Math.max(0, state.bombReadyAt - state.t));
      if (unlocked) {
        btnBomb.style.display = 'flex';
        btnBomb.textContent = bombReady() ? `ðŸ’£ BOMB (${type})` : `ðŸ’£ ${type} (${cd}s)`;
        btnBomb.style.opacity = bombReady() ? '1' : '0.6';
      } else {
        btnBomb.style.display = 'none';
      }
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  // Show bomb/boost buttons if unlocked
  function checkUnlocksAndToggleButtons() {
    const bombUnlocked = !!state.save["bomb unlocked"];
    const boostUnlocked = !!state.save["boost unlocked"];
    document.getElementById('btnBomb').style.display = bombUnlocked ? 'flex' : 'none';
    document.getElementById('btnBoost').style.display = boostUnlocked ? 'flex' : 'none';
  }

  checkUnlocksAndToggleButtons();

  // Bomb click (after toggle)
  document.getElementById('btnBomb')?.addEventListener('click', (e